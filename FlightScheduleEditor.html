<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ground ATC - èˆªç­æ—¶åˆ»è¡¨ç¼–è¾‘å™¨</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --panel-color: #252526;
            --border-color: #3e3e42;
            --text-color: #d4d4d4;
            --accent-color: #007acc;
            --accent-hover: #0062a3;
            --danger-color: #f44336;
            --header-bg: #333333;
            --row-hover: #2a2d2e;
            --input-bg: #3c3c3c;
            --input-border: #3e3e42;
            --locked-bg: #2d2d2d;
            --locked-text: #888;
            /* Visual States */
            --duplicate-bg: rgba(255, 140, 0, 0.15);
            --duplicate-border: #ff8c00;
            --selected-bg: rgba(0, 120, 215, 0.3);
            --selected-border: #007acc;
            /* Stand Conflict States */
            --conflict-bg: rgba(244, 67, 54, 0.15);
            --conflict-border: #f44336;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* Toolbar */
        .toolbar {
            background-color: var(--panel-color);
            padding: 10px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 15px;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            flex-wrap: wrap;
        }

        .title {
            font-weight: bold;
            font-size: 1.2em;
            margin-right: 10px;
            color: #fff;
        }

        /* Input Group in Toolbar */
        .input-group {
            display: flex;
            align-items: center;
            gap: 5px;
            background-color: #333;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .input-group label {
            font-size: 0.85em;
            color: #aaa;
        }

        .input-group input {
            background-color: transparent;
            border: none;
            color: white;
            font-weight: bold;
            text-align: center;
            outline: none;
        }

        .input-group input:focus {
            background-color: #444;
        }

        button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 6px 14px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.2s;
            white-space: nowrap;
        }

        button:hover {
            background-color: var(--accent-hover);
        }

        button.secondary {
            background-color: #444;
        }

        button.secondary:hover {
            background-color: #555;
        }

        button.active-lock {
            background-color: #e6a23c;
            color: #fff;
        }

        button.active-lock:hover {
            background-color: #cf9236;
        }

        button.danger {
            background-color: var(--danger-color);
        }

        button:disabled {
            background-color: #333;
            color: #666;
            cursor: not-allowed;
            border: 1px solid #444;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
        }

        /* Tabs */
        /* Tabs - Skeuomorphic Refactor */
        .tabs {
            display: flex;
            background-color: transparent;
            /* Remove border-bottom and use gap */
            gap: 12px;
            padding: 10px 10px 0 10px;
            position: relative;
            z-index: 5;
        }

        .tab {
            padding: 12px 24px;
            cursor: pointer;
            border-radius: 12px 12px 0 0;
            background-color: var(--panel-color);
            color: #888;
            font-size: 0.9em;
            font-weight: 500;
            border: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            /* Subtle shadow for depth */
            box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.1);
        }

        .tab:after {
            /* Connecting curve hack (optional, kept simple for now) */
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 1px;
            background-color: var(--border-color);
            z-index: -1;
        }

        .tab:hover {
            background-color: #333;
            color: #ccc;
        }

        .tab.active {
            background-color: var(--bg-color);
            color: var(--accent-color);
            text-shadow: 0 0 8px rgba(0, 238, 255, 0.5);
            /* Remove bottom border visual by covering it */
            box-shadow: 0 -4px 8px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }

        .tab.active:after {
            background-color: var(--bg-color);
            height: 2px;
            bottom: -1px;
        }

        /* Content Area */
        .content {
            flex: 1;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .table-container {
            flex: 1;
            overflow: auto;
            padding-bottom: 50px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            min-width: 1200px;
        }

        th,
        td {
            border: 1px solid var(--border-color);
            padding: 4px 8px;
            text-align: left;
            white-space: nowrap;
        }

        th {
            background-color: var(--header-bg);
            position: sticky;
            top: 0;
            z-index: 10;
            font-weight: 600;
            color: #ddd;
        }

        tr:nth-child(even) {
            background-color: #222;
        }

        tr:hover {
            background-color: var(--row-hover);
        }

        /* Duplicate Styling */
        tr.duplicate-row {
            background-color: var(--duplicate-bg) !important;
        }

        tr.highlight-group {
            outline: 2px solid var(--duplicate-border);
            background-color: rgba(255, 140, 0, 0.4) !important;
            z-index: 5;
            position: relative;
        }

        /* Selected Styling */
        tr.selected-row {
            background-color: var(--selected-bg) !important;
        }

        tr.duplicate-row.selected-row {
            background-color: rgba(0, 120, 215, 0.4) !important;
            box-shadow: inset 3px 0 0 var(--duplicate-border);
        }

        /* Stand Conflict Styling */
        tr.conflict-row {
            background-color: var(--conflict-bg) !important;
        }

        tr.highlight-conflict {
            outline: 2px solid var(--conflict-border);
            background-color: rgba(244, 67, 54, 0.4) !important;
            z-index: 5;
            position: relative;
        }

        tr.conflict-row.selected-row {
            background-color: rgba(244, 67, 54, 0.3) !important;
            box-shadow: inset 3px 0 0 var(--conflict-border);
        }

        /* åŒæ—¶æœ‰é‡å¤å‘¼å·å’Œåœæœºä½å†²çª */
        tr.duplicate-row.conflict-row {
            background: linear-gradient(90deg, var(--duplicate-bg) 50%, var(--conflict-bg) 50%);
        }

        /* Turnaround Stand Highlighting (Yellow) */
        tr.turnaround-row {
            background-color: rgba(255, 193, 7, 0.2) !important;
        }

        tr.highlight-turnaround {
            outline: 2px solid #ffc107;
            background-color: rgba(255, 193, 7, 0.4) !important;
            z-index: 5;
            position: relative;
        }

        /* Clickable turnaround badge in modal */
        .turnaround-badge {
            display: inline-block;
            padding: 2px 8px;
            margin: 2px;
            background-color: #333;
            border: 1px solid #ffc107;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .turnaround-badge:hover {
            background-color: #ffc107;
            color: #000;
        }

        input,
        select {
            background-color: transparent;
            border: 1px solid transparent;
            color: inherit;
            width: 100%;
            padding: 4px;
            box-sizing: border-box;
            font-family: inherit;
            font-size: inherit;
        }

        input:focus,
        select:focus {
            background-color: var(--input-bg);
            border-color: var(--accent-color);
            outline: none;
        }

        input:focus {
            background-color: #264f78 !important;
        }

        /* Locked Input Style */
        input.locked {
            background-color: var(--locked-bg);
            color: var(--locked-text);
            cursor: not-allowed;
            border: 1px solid transparent;
            font-style: italic;
        }

        input.header-offset {
            width: 40px;
            font-size: 0.9em;
            background-color: #444;
            border: 1px solid #555;
            color: #fff;
            margin-left: 5px;
            border-radius: 3px;
            text-align: center;
        }

        input.header-offset:focus {
            background-color: #555;
            border-color: var(--accent-color);
        }

        .cell-time {
            width: 90px;
            text-align: center;
        }

        .cell-code {
            width: 80px;
            font-family: monospace;
        }

        .cell-long {
            width: 150px;
        }

        .cell-action {
            width: 50px;
            text-align: center;
        }

        .btn-delete {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
        }

        .btn-delete:hover {
            color: var(--danger-color);
        }

        .add-row-bar {
            padding: 10px;
            background-color: var(--panel-color);
            border-top: 1px solid var(--border-color);
            text-align: center;
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .status-bar {
            padding: 5px 20px;
            background-color: var(--accent-color);
            color: white;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }

        /* Modal Overlay */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: var(--panel-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 24px;
            min-width: 320px;
            max-width: 400px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .modal-content h3 {
            margin: 0 0 8px 0;
            color: #fff;
            font-size: 1.2em;
        }

        .modal-desc {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 20px;
        }

        .modal-field {
            margin-bottom: 16px;
        }

        .modal-field label {
            display: block;
            margin-bottom: 6px;
            color: #aaa;
            font-size: 0.9em;
        }

        .modal-field input {
            width: 100%;
            padding: 8px 12px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: #fff;
            font-size: 1em;
            box-sizing: border-box;
        }

        .modal-field input:focus {
            border-color: var(--accent-color);
            outline: none;
        }

        .modal-info {
            background-color: rgba(0, 122, 204, 0.15);
            border: 1px solid var(--accent-color);
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 0.85em;
            color: #ccc;
            line-height: 1.6;
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        /* === Stand View (Skeuomorphic Style) === */
        :root {
            --skeuo-bg: #2b2b30;
            --skeuo-inset-bg: #1e1e24;
            --skeuo-light-shadow: #3e3e44;
            --skeuo-dark-shadow: #19191c;
            /* --skeuo-text-glow: #00e5ff; */
            /* Cyan */
            --skeuo-text-glow: #0ac;
            /* Softer Cyan */
        }

        #standView {
            background-color: #1e1e24;
            /* Subtle grid pattern or noise could be nice, but simple dark bg works */
        }

        .stand-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 25px;
            padding: 20px;
            align-items: start;
            /* Critical for independent height */
        }

        .stand-card {
            background-color: var(--skeuo-bg);
            border-radius: 20px;
            /* Outset Shadow */
            box-shadow:
                8px 8px 16px var(--skeuo-dark-shadow),
                -8px -8px 16px var(--skeuo-light-shadow);
            padding: 20px;
            color: #ccc;
            transition: box-shadow 0.3s ease, border 0.3s ease;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        /* Conflict state for stand card */
        .stand-card.conflict {
            background-color: rgba(139, 0, 0, 0.3);
            border: 2px solid #f44336;
            box-shadow:
                0 0 15px rgba(244, 67, 54, 0.4),
                8px 8px 16px var(--skeuo-dark-shadow),
                -8px -8px 16px var(--skeuo-light-shadow);
        }

        /* Card Header */
        .stand-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 40px;
            margin-bottom: 15px;
        }

        .stand-title-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        /* Toggle Button (Round) */
        .stand-toggle-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(145deg, #2e2e33, #27272b);
            box-shadow: 4px 4px 8px var(--skeuo-dark-shadow),
                -4px -4px 8px var(--skeuo-light-shadow);
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            outline: none;
            transition: all 0.2s ease;
        }

        .stand-toggle-btn:active {
            box-shadow: inset 3px 3px 6px var(--skeuo-dark-shadow),
                inset -3px -3px 6px var(--skeuo-light-shadow);
        }

        .stand-toggle-btn svg {
            fill: #888;
            transition: transform 0.3s ease-out;
            width: 20px;
            height: 20px;
        }

        .stand-card.expanded .stand-toggle-btn svg {
            transform: rotate(90deg);
            fill: var(--skeuo-text-glow);
        }

        /* Stand Number Title */
        .stand-number {
            font-size: 1.2em;
            font-weight: bold;
            color: var(--skeuo-text-glow);
            text-shadow: 0 0 8px rgba(0, 238, 255, 0.3);
            letter-spacing: 1px;
            font-family: 'Segoe UI', sans-serif;
        }

        /* Header Stats */
        .stand-stats {
            display: flex;
            gap: 10px;
            font-size: 0.85em;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 3px;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Microsoft YaHei UI', sans-serif;
        }

        .stat-item .stat-label {
            font-weight: 500;
        }

        .stat-item .stat-count {
            font-weight: bold;
        }

        .stat-item.stat-arr {
            color: #4CAF50;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .stat-item.stat-dep {
            color: #2196F3;
            border: 1px solid rgba(33, 150, 243, 0.3);
        }

        /* Flight indicator dots */
        .flight-dot {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin: 0 1px;
            box-shadow: 0 0 4px currentColor;
            cursor: help;
        }

        /* Expandable Content (Inset Screen) */
        .stand-body {
            max-height: 0;
            overflow: hidden;
            margin-top: 0;
            transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                margin-top 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .stand-card.expanded .stand-body {
            /* JS will set specific max-height or we use a large enough value */
            max-height: 500px;
            margin-top: 10px;
        }

        .stand-list-container {
            background-color: var(--skeuo-inset-bg);
            border-radius: 12px;
            box-shadow: inset 4px 4px 8px var(--skeuo-dark-shadow),
                inset -4px -4px 8px var(--skeuo-light-shadow);
            padding: 10px 15px;
        }

        .flight-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.03);
            border: 1px solid transparent;
            transition: background-color 0.2s ease;
            font-size: 0.9em;
        }

        .flight-item:last-child {
            margin-bottom: 0;
        }

        .flight-item.type-arr {
            border: 2px solid rgba(76, 175, 80, 0.8);
            box-shadow: 0 0 12px rgba(76, 175, 80, 0.3), inset 0 0 10px rgba(76, 175, 80, 0.05);
        }

        .flight-item.type-dep {
            border: 2px solid rgba(33, 150, 243, 0.8);
            box-shadow: 0 0 12px rgba(33, 150, 243, 0.3), inset 0 0 10px rgba(33, 150, 243, 0.05);
        }

        .flight-callsign {
            color: #ddd;
            font-weight: 500;
            flex: 1;
            /* å‡åˆ†å‰©ä½™ç©ºé—´ */
            text-align: center;
            /* å±…ä¸­æ˜¾ç¤ºä»¥è„±ç¦»å›¾æ ‡ */
        }

        .flight-actype-trigger {
            background-color: transparent;
            color: #ccc;
            font-size: 0.8em;
            flex: 1.4;
            text-align: center;
            margin-right: 4px;
            padding: 2px 18px 2px 8px;
            border-radius: 12px;
            border-width: 1px;
            border-style: solid;
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            /* Arrow Icon */
            background-repeat: no-repeat;
            background-position: right 4px center;
            background-size: 16px;
            user-select: none;
            transition: background-color 0.2s;
        }

        .flight-actype-trigger:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        /* Arrival Style */
        .flight-actype-trigger.type-arr {
            border-color: rgba(76, 175, 80, 0.8);
            color: #a5d6a7;
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%234caf50'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
        }

        /* Departure Style */
        .flight-actype-trigger.type-dep {
            border-color: rgba(33, 150, 243, 0.8);
            color: #90caf9;
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%232196f3'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
        }

        /* Custom Dropdown Container */
        .custom-dropdown {
            position: fixed;
            z-index: 10000;
            background-color: #2d2d30;
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid #444;
            padding: 6px;
            font-family: 'Segoe UI', sans-serif;
            font-size: 0.9em;
            min-width: 140px;
            /* Scrollbar styling */
            scrollbar-width: thin;
            scrollbar-color: #555 transparent;
        }

        .custom-dropdown::-webkit-scrollbar {
            width: 6px;
        }

        .custom-dropdown::-webkit-scrollbar-thumb {
            background-color: #555;
            border-radius: 3px;
        }

        .custom-dropdown.type-arr {
            border: 1px solid rgba(76, 175, 80, 0.6);
            box-shadow: 0 8px 24px rgba(76, 175, 80, 0.15);
        }

        .custom-dropdown.type-dep {
            border: 1px solid rgba(33, 150, 243, 0.6);
            box-shadow: 0 8px 24px rgba(33, 150, 243, 0.15);
        }

        .custom-dropdown-item {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 6px;
            color: #ddd;
            margin-bottom: 2px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .custom-dropdown-item:hover {
            background-color: rgba(255, 255, 255, 0.08);
        }

        /* Selected State */
        .custom-dropdown-item.selected.type-arr {
            background-color: rgba(76, 175, 80, 0.25);
            color: #a5d6a7;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .custom-dropdown-item.selected.type-dep {
            background-color: rgba(33, 150, 243, 0.25);
            color: #90caf9;
            border: 1px solid rgba(33, 150, 243, 0.3);
        }

        .flight-time {
            font-family: 'Microsoft YaHei UI', 'Segoe UI', sans-serif;
            color: #aaa;
            flex: 0.8;
            text-align: right;
            min-width: 45px;
        }

        .flight-tag {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2),
                inset 1px 1px 2px rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.1s ease;
        }

        .flight-tag.pressed {
            box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.4),
                inset -2px -2px 5px rgba(255, 255, 255, 0.1) !important;
            filter: brightness(0.9);
        }

        .tag-arr {
            border: 1px solid #2e7d32;
            background: linear-gradient(135deg, #4caf50, #2e7d32);
        }

        .tag-dep {
            border: 1px solid #1565c0;
            background: linear-gradient(135deg, #2196f3, #1565c0);
        }

        /* Arrow icons for flight type */
        .arrow-icon {
            width: 18px;
            height: 18px;
            fill: none;
            stroke-width: 5.5;
            stroke-linecap: round;
            stroke-linejoin: round;
            /* Stroke color defined by subclass */
        }

        .arrow-icon.arr {
            stroke: #1b5e20;
        }

        .arrow-icon.dep {
            stroke: #0d47a1;
        }

        /* ===== Drag & Drop Styles ===== */
        .flight-item.dragging {
            opacity: 0.3;
            pointer-events: none;
        }

        .drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.85;
            transform: scale(1.02);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            transition: transform 0.1s ease;
        }

        .stand-card.drag-over {
            box-shadow: 0 0 20px rgba(0, 238, 255, 0.6),
                8px 8px 16px var(--skeuo-dark-shadow),
                -8px -8px 16px var(--skeuo-light-shadow);
            border-color: var(--skeuo-text-glow) !important;
        }

        .stand-card.drag-over-invalid {
            box-shadow: 0 0 20px rgba(244, 67, 54, 0.6),
                8px 8px 16px var(--skeuo-dark-shadow),
                -8px -8px 16px var(--skeuo-light-shadow);
            border-color: #f44336 !important;
        }

        .stand-list-container {
            /* transition properties are managed by .anim-expand and .anim-shrink classes via JS */
            position: relative;
            /* Ensure stacking context */
        }

        .anim-expand {
            transition: height 0.4s cubic-bezier(0.34, 1.15, 0.64, 1);
            /* Bounce */
        }

        .anim-shrink {
            transition: height 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            /* Smooth */
        }

        body.is-dragging {
            user-select: none;
            cursor: grabbing !important;
        }

        body.is-dragging * {
            cursor: grabbing !important;
        }

        .empty-stand-msg {
            text-align: center;
            color: #555;
            padding: 20px 0;
            font-style: italic;
        }
    </style>
</head>

<body>

    <div class="toolbar">
        <div class="title">âœˆï¸ Ground ATC Editor</div>

        <button onclick="newFile()" class="secondary">æ–°å»º (æ¸…ç©º)</button>

        <div class="file-input-wrapper">
            <button>ğŸ“‚ æ‰“å¼€ CSV</button>
            <input type="file" id="csvInput" accept=".csv" onchange="loadCSV(this)">
        </div>

        <div class="file-input-wrapper">
            <button class="secondary">âš™ï¸ ä¸Šä¼ é…ç½® (CFG)</button>
            <input type="file" id="cfgInput" accept=".cfg,.txt" multiple onchange="loadConfigs(this)">
        </div>

        <div class="file-input-wrapper">
            <button class="secondary">ğŸ“ å¯¼å…¥å‘¼å·è¡¨</button>
            <input type="file" id="callsignInput" accept=".csv" onchange="loadCallsigns(this)">
        </div>

        <!-- Airport Code Lock -->
        <div class="input-group">
            <label for="airportCode">å½“å‰æœºåœº:</label>
            <input type="text" id="airportCode" placeholder="ICAO" maxlength="4"
                style="width: 50px; text-transform: uppercase;">
            <button id="btnLock" class="secondary" onclick="toggleAirportLock()"
                style="padding: 2px 8px; font-size: 0.8em;">ğŸ”“ é”å®š</button>
        </div>

        <div style="flex:1"></div>

        <div class="input-group">
            <label for="exportFilename">æ–‡ä»¶å:</label>
            <input type="text" id="exportFilename" placeholder="flight_schedule" style="width: 150px;"
                value="flight_schedule">
            <span style="color: #888;">.csv</span>
        </div>
        <button onclick="downloadCSV()" style="background-color: #4CAF50;">ğŸ’¾ å¯¼å‡º CSV</button>
    </div>

    <div class="tabs">
        <div class="tab active" onclick="switchTab('arrival')">ğŸ›¬ åˆ°è¾¾èˆªç­ (Arrivals)</div>
        <div class="tab" onclick="switchTab('departure')">ğŸ›« å‡ºå‘èˆªç­ (Departures)</div>
        <div class="tab" onclick="switchTab('all')">ğŸ“‹ å…¨éƒ¨èˆªç­ (All)</div>
        <div class="tab" onclick="switchTab('standView')">ğŸ¢ åœæœºåªè§†å›¾ (Stands)</div>
    </div>

    <div class="content">
        <!-- List View Container -->
        <div id="listViewContainer" style="display: flex; flex-direction: column; flex: 1; overflow: hidden;">
            <div class="table-container">
                <table id="dataTable">
                    <thead>
                        <tr id="headerRow">
                            <!-- Headers injected by JS -->
                        </tr>
                    </thead>
                    <tbody id="tableBody">
                        <!-- Rows injected by JS -->
                    </tbody>
                </table>
            </div>

            <div class="add-row-bar">
                <!-- New Batch Buttons with Logic Fix -->
                <button id="btnSetArr" class="secondary" onclick="batchSetAsArrival()" disabled title="éœ€é”å®šå½“å‰æœºåœº">ğŸ“¥
                    è®¾ç½®åˆ°è¾¾</button>
                <button id="btnSetDep" class="secondary" onclick="batchSetAsDeparture()" disabled title="éœ€é”å®šå½“å‰æœºåœº">ğŸ“¤
                    è®¾ç½®å‡ºå‘</button>
                <div style="width: 20px; border-right: 1px solid #444; margin-right: 10px;"></div>
                <button class="secondary" onclick="deduplicateCallsigns()" title="è‡ªåŠ¨ä¿®å¤é‡å¤å‘¼å·">ğŸ”§ å‘¼å·å»é‡</button>
                <button id="btnAutoSchedule" class="secondary" onclick="openAutoScheduleModal()" title="è‡ªåŠ¨åˆ†é…æ—¶é—´">â±ï¸
                    è‡ªåŠ¨é…è¡¨</button>
                <button id="btnAirportInfo" class="secondary" onclick="openAirportInfoModal()" title="é…ç½®æœºåœºåœæœºä½">ğŸ¢
                    æœºåœºä¿¡æ¯</button>
                <button onclick="addRow()">+ æ·»åŠ èˆªç­</button>
            </div>
        </div>

        <!-- Stand View Container -->
        <div id="standViewContainer"
            style="display: none; height: 100%; overflow-y: auto; background-color: var(--skeuo-inset-bg);">
            <div id="standGrid" class="stand-grid">
                <!-- Stand Cards Injected Here -->
            </div>
        </div>
    </div>

    <div class="status-bar" id="statusBar">
        <span id="statusMsg">å°±ç»ª</span>
        <span id="selectionInfo" style="color: #00e5ff;"></span>
        <span id="statsInfo">èˆªç­æ•°: 0</span>
    </div>

    <!-- è‡ªåŠ¨é…è¡¨å¯¹è¯æ¡† -->
    <div id="autoScheduleModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h3>â±ï¸ è‡ªåŠ¨é…è¡¨</h3>
            <p class="modal-desc">ä¸ºå½“å‰è§†å›¾ä¸­çš„èˆªç­è‡ªåŠ¨åˆ†é…æ—¶é—´</p>

            <div class="modal-field">
                <label for="autoStartTime">å¼€å§‹æ—¶é—´:</label>
                <input type="text" id="autoStartTime" placeholder="HH:mm:ss" value="08:00:00">
            </div>

            <div class="modal-field">
                <label for="autoInterval">é—´éš”æ—¶é—´ (åˆ†é’Ÿ):</label>
                <input type="number" id="autoInterval" value="5" min="1" max="120">
            </div>

            <hr style="border-color: #444; margin: 16px 0;">

            <div class="modal-field">
                <label for="autoTimeOffset">æ—¶é—´åç§» (åˆ†é’Ÿ):</label>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <input type="number" id="autoTimeOffset" value="0" style="flex: 1;">
                    <span style="color: #888; font-size: 0.85em;">æ­£æ•°=å»¶åï¼Œè´Ÿæ•°=æå‰</span>
                </div>
            </div>

            <div class="modal-info" id="autoSchedulePreview">
                <!-- é¢„è§ˆä¿¡æ¯åŠ¨æ€ç”Ÿæˆ -->
            </div>

            <div class="modal-actions">
                <button class="secondary" onclick="closeAutoScheduleModal()">å–æ¶ˆ</button>
                <button class="secondary" onclick="applyTimeOffset()" style="background-color: #1565C0;">â³ ä»…åç§»</button>
                <button onclick="applyAutoSchedule()">âœ“ åº”ç”¨é…è¡¨</button>
            </div>
        </div>
    </div>

    <!-- æœºåœºä¿¡æ¯å¯¹è¯æ¡† -->
    <div id="airportInfoModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h3>ğŸ¢ æœºåœºä¿¡æ¯</h3>
            <p class="modal-desc">é…ç½®å½“å‰æœºåœºçš„åœæœºä½ä¿¡æ¯</p>

            <div class="modal-field">
                <label for="standCount">åœæœºä½æ•°é‡:</label>
                <input type="number" id="standCount" placeholder="ä¾‹å¦‚: 12" value="" min="1" max="99">
            </div>

            <div class="modal-info" id="airportInfoPreview">
                <div><strong>å½“å‰çŠ¶æ€:</strong> æœªé…ç½®åœæœºä½</div>
            </div>

            <div class="modal-actions">
                <button class="secondary" onclick="closeAirportInfoModal()">å–æ¶ˆ</button>
                <button onclick="applyAirportInfo()">âœ“ ç”Ÿæˆåœæœºä½</button>
            </div>
        </div>
    </div>

    <!-- ç¡®è®¤å¯¹è¯æ¡† -->
    <div id="confirmModal" class="modal-overlay" style="display: none; z-index: 2000;">
        <div class="modal-content" style="max-width: 360px;">
            <h3>âš ï¸ ç¡®è®¤æ“ä½œ</h3>
            <p id="confirmMessage" style="color: #ddd; line-height: 1.5; margin-bottom: 20px;"></p>
            <div class="modal-actions">
                <button class="secondary" id="btnConfirmCancel">å–æ¶ˆ</button>
                <button id="btnConfirmOk" style="background-color: #c62828;">ç¡®å®š</button>
            </div>
        </div>
    </div>

    <!-- é€šç”¨æç¤ºå¯¹è¯æ¡† -->
    <div id="alertModal" class="modal-overlay" style="display: none; z-index: 2000;">
        <div class="modal-content" style="max-width: 360px;">
            <h3 id="alertTitle">â„¹ï¸ æç¤º</h3>
            <p id="alertMessage" style="color: #ddd; line-height: 1.5; margin-bottom: 20px;"></p>
            <div class="modal-actions">
                <button id="btnAlertOk">ç¡®å®š</button>
            </div>
        </div>
    </div>

    <!-- Script -->
    <script>
        const defaultCallsignsCSV = `callSign,airline
CCA3115,CCA
CDG2701,CDG
CDG8001,CDG
CDG8031,CDG
CDG8085,CDG
CDG8416,CDG
CES1111,CES
CES5657,CES
CES9197,CES
CFE2281,CFE
CFE3492,CFE
CFE4462,CFE
CFE8461,CFE
CFE8703,CFE
CFE8704,CFE
CFE8739,CFE
CHH7306,CHH
CJX8923,CJX
CQH6596,CQH
CQH7171,CQH
CSC3612,CSC
CSC6918,CSC
CSC8056,CSC
CSN3712,CSN
CSN8545,CSN
CSN8733,CSN
CSZ2861,CSZ
CSZ3690,CSZ
CXA8069,CXA
UEA1889,UEA
UEA7323,UEA`;

        let allFlights = [];
        let currentTab = 'arrival';
        let currentAirportCode = "";
        let isAirportLocked = false;

        let selectedIndices = new Set();
        let lastVisualIndex = null;

        let timeOffsets = { arrival: 10, departure: 10 };
        let exportDirHandle = null; // å¯¼å‡ºç›®å½•å¥æŸ„

        let config = {
            aircraftTypes: [
                "AIRBUS A-320ceo", "AIRBUS A-320neo", "AIRBUS A-321neo", "AIRBUS A-330-300",
                "AIRBUS A-350-900", "BOEING 737 MAX 8", "BOEING 737-800", "BOEING 747-8I",
                "BOEING 777-300ER", "COMAC C-919"
            ],
            airlines: [
                "AAL", "AFR", "ASA", "AVA", "BAW", "CCA", "CDG", "CES", "CHH", "CJX", "CQH",
                "CSC", "CSN", "CSZ", "CXA", "DAL", "DKH", "FFT", "GCR", "HXA", "JAL", "JZA",
                "KNA", "KPA", "LKE", "OKA", "OTC", "QTR", "RYR", "SIA", "SWR", "THA", "TVB",
                "UAL", "UEA", "VIR"
            ],
            callsigns: [],
            stands: [],
            voices: ["CN-Captain-Young", "CN-Captain-Middle-Aged", "CN-Captain-Young-EN"],
            languages: ["zh", "en"],

            mapping: {
                aircraftToAirlines: {},
                airlineToAircrafts: {},
                callsignToAirline: {},
                airlineToCallsigns: {}
            }
        };

        window.onload = function () {
            // Default mapping init (from AircraftLiveryPath.cfg)
            const defaultAcMap = {
                "AIRBUS A-320ceo": ["CCA", "CES", "CHH", "CQH", "CSC", "CSN", "CSZ", "UEA"],
                "AIRBUS A-320neo": ["AVA", "BAW", "CCA", "CES", "CHH", "CQH", "CSC", "CSN", "CSZ", "FFT", "UEA"],
                "AIRBUS A-321neo": ["AAL", "DAL", "FFT", "JBU"],
                "AIRBUS A-330-300": ["CCA", "CSN", "VIR"],
                "AIRBUS A-350-900": ["AFR", "DAL", "JAL"],
                "BOEING 737 MAX 8": ["CDG", "CSN"],
                "BOEING 737-800": ["AAL", "ASA", "CDG", "CES", "CHH", "CJX", "CSN", "CXA", "DAL", "SWA", "UAL"],
                "BOEING 747-8I": ["CCA", "DLH", "KAL"],
                "BOEING 777-300ER": ["ACA", "AFR", "BAW", "CCA", "UAL"],
                "COMAC C-919": ["CCA", "CES", "CSN"]
            };
            config.mapping.aircraftToAirlines = defaultAcMap;

            buildReverseMapping();
            parseCallsignConfig(defaultCallsignsCSV);
            renderHeader();
            renderTable();
            updateStats();
            updateBatchButtons();

            // ç»‘å®šè‡ªåŠ¨é…è¡¨è¾“å…¥äº‹ä»¶
            document.getElementById('autoStartTime').addEventListener('input', updateAutoSchedulePreview);
            document.getElementById('autoInterval').addEventListener('input', updateAutoSchedulePreview);

            // ç»‘å®šæœºåœºä¿¡æ¯è¾“å…¥äº‹ä»¶
            document.getElementById('standCount').addEventListener('input', updateAirportInfoPreview);
        };

        function buildReverseMapping() {
            config.mapping.airlineToAircrafts = {};
            config.airlines.forEach(al => config.mapping.airlineToAircrafts[al] = []);
            for (const [acType, allowedAirlines] of Object.entries(config.mapping.aircraftToAirlines)) {
                allowedAirlines.forEach(al => {
                    if (!config.mapping.airlineToAircrafts[al]) config.mapping.airlineToAircrafts[al] = [];
                    if (!config.mapping.airlineToAircrafts[al].includes(acType)) config.mapping.airlineToAircrafts[al].push(acType);
                });
            }
        }

        const headers = [
            { key: 'callSign', label: 'å‘¼å·', type: 'select', source: 'callsigns', width: '120px', required: true },
            { key: 'departure', label: 'èµ·é£æœºåœº', width: '80px', required: true },
            { key: 'arrival', label: 'åˆ°è¾¾æœºåœº', width: '80px', required: true },
            { key: 'stand', label: 'åœæœºä½', type: 'select', source: 'stands', width: '70px', required: true },
            { key: 'runway', label: 'è·‘é“', width: '60px', required: true },
            { key: 'offBlockTime', label: 'æ¨å‡ºæ—¶é—´', type: 'time', tab: 'departure', hasSwapBtn: true },
            { key: 'takeOffTime', label: 'èµ·é£æ—¶é—´', type: 'time', tab: 'departure', hasOffset: true },
            { key: 'landingTime', label: 'ç€é™†æ—¶é—´', type: 'time', tab: 'arrival', hasSwapBtn: true },
            { key: 'inBlockTime', label: 'å…¥ä½æ—¶é—´', type: 'time', tab: 'arrival', hasOffset: true },
            { key: 'airline', label: 'èˆªå¸', type: 'select', source: 'airlines', width: '80px' },
            { key: 'aircraftType', label: 'æœºå‹', type: 'select', source: 'aircraftTypes', width: '150px' },
            { key: 'voice', label: 'è¯­éŸ³', type: 'select', source: 'voices', width: '120px' },
            { key: 'language', label: 'è¯­è¨€', type: 'select', source: 'languages', width: '60px' },
        ];

        // Stand View State
        let expandedStands = new Set();
        const sortStands = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' }).compare;

        function switchTab(tab) {
            currentTab = tab;
            selectedIndices.clear();
            lastVisualIndex = null;
            document.querySelectorAll('.tab').forEach(el => el.classList.remove('active'));
            // Fix: event might not be available if called programmatically, use strict check
            if (window.event && window.event.target.classList.contains('tab')) {
                window.event.target.classList.add('active');
            } else {
                // If called programmatically, find tab
                const tabs = document.querySelectorAll('.tab');
                if (tab === 'arrival') tabs[0].classList.add('active');
                if (tab === 'departure') tabs[1].classList.add('active');
                if (tab === 'all') tabs[2].classList.add('active');
                if (tab === 'standView') tabs[3].classList.add('active');
            }

            const listView = document.getElementById('listViewContainer');
            const standView = document.getElementById('standViewContainer');

            if (tab === 'standView') {
                listView.style.display = 'none';
                standView.style.display = 'block';
                renderStandView();
            } else {
                listView.style.display = 'flex'; // Changed to flex as defined in HTML
                standView.style.display = 'none';
                renderHeader();
                renderTable();
            }
        }

        // === Stand View Rendering ===
        function renderStandView() {
            const container = document.getElementById('standGrid');
            container.innerHTML = '';

            // 1. Check if stands are configured
            if (!config.stands || config.stands.length === 0) {
                container.innerHTML = '<div class="empty-stand-msg" style="grid-column: 1/-1;">æš‚æ— åœæœºä½ä¿¡æ¯ï¼Œè¯·å…ˆåœ¨ä¸‹æ–¹å·¥å…·æ ç‚¹å‡»"ğŸ¢ æ¯æœºä½ä¿¡æ¯"è¿›è¡Œé…ç½®ã€‚</div>';
                return;
            }

            // 2. Group flights by stand
            const standData = {};
            config.stands.forEach(s => {
                standData[s] = { arrivals: [], departures: [] };
            });

            allFlights.forEach((f, idx) => {
                if (f.stand && standData[f.stand]) {
                    const type = getFlightType(f);
                    // ä¿ç•™åŸå§‹ç´¢å¼•ç”¨äºæ‹–æ‹½
                    const flightWithIndex = { ...f, _index: idx };
                    if (type === 'arrival') standData[f.stand].arrivals.push(flightWithIndex);
                    else standData[f.stand].departures.push(flightWithIndex);
                }
            });

            // 3. Sort stands
            const sortedStands = [...config.stands].sort(sortStands);

            // 4. Generate Cards
            sortedStands.forEach(stand => {
                const data = standData[stand];
                const card = document.createElement('div');
                card.id = `stand-card-${stand}`;

                // Content HTML
                const arrCount = data.arrivals.length;
                const depCount = data.departures.length;

                // å†²çªæ£€æµ‹ï¼šå¤šåˆ°è¾¾ æˆ– å…ˆè¿›åå‡º
                let hasConflict = false;

                // è§„åˆ™1: å¤šåˆ°è¾¾å†²çª (â‰¥2 ä¸ªåˆ°è¾¾èˆªç­)
                if (arrCount >= 2) {
                    hasConflict = true;
                }

                // è§„åˆ™2: åˆ°è¾¾-å‡ºå‘æ—¶é—´å†²çª (å…ˆè¿›åå‡º)
                if (!hasConflict && arrCount >= 1 && depCount >= 1) {
                    data.arrivals.forEach(arr => {
                        data.departures.forEach(dep => {
                            const arrInBlock = arr.inBlockTime || arr.landingTime;
                            const depTakeOff = dep.takeOffTime || dep.offBlockTime;
                            // å†²çªæ¡ä»¶ï¼šåˆ°è¾¾å…¥ä½æ—¶é—´ <= å‡ºå‘èµ·é£æ—¶é—´
                            if (arrInBlock && depTakeOff && compareTime(arrInBlock, depTakeOff) <= 0) {
                                hasConflict = true;
                            }
                        });
                    });
                }

                // Apply conflict class
                card.className = `stand-card ${expandedStands.has(stand) ? 'expanded' : ''} ${hasConflict ? 'conflict' : ''}`;

                // Flight List HTML
                let flightListHtml = '';

                // åˆ›å»ºæŒ‰æ—¶é—´æ’åºçš„èˆªç­åºåˆ—ï¼ˆç”¨äºå›¾æ ‡æ˜¾ç¤ºï¼‰
                const sortedFlightsForIcons = [
                    ...data.arrivals.map(f => ({ _type: 'arr', _time: f.landingTime || f.inBlockTime })),
                    ...data.departures.map(f => ({ _type: 'dep', _time: f.offBlockTime || f.takeOffTime }))
                ].sort((a, b) => (a._time || '').localeCompare(b._time || ''));

                // ç”Ÿæˆå›¾æ ‡HTML
                let iconsHtml = '';
                sortedFlightsForIcons.forEach(f => {
                    const color = f._type === 'arr' ? '#4CAF50' : '#2196F3';
                    const title = f._type === 'arr' ? 'è¿›æ¸¯' : 'å‡ºæ¸¯';
                    iconsHtml += `<span class="flight-dot" style="background-color:${color};" title="${title} ${f._time || ''}"></span>`;
                });
                if (sortedFlightsForIcons.length === 0) {
                    iconsHtml = '<span style="color:#555;font-size:0.8em;">(ç©ºé—²)</span>';
                }

                if (arrCount + depCount === 0) {
                    flightListHtml = '<div style="text-align:center; padding:10px; color:#555;">(ç©ºé—²)</div>';
                } else {
                    // Combine and sort by time
                    const allStandFlights = [
                        ...data.arrivals.map(f => ({ ...f, _type: 'arr', _time: f.landingTime || f.inBlockTime })),
                        ...data.departures.map(f => ({ ...f, _type: 'dep', _time: f.offBlockTime || f.takeOffTime }))
                    ].sort((a, b) => (a._time || '').localeCompare(b._time || ''));

                    allStandFlights.forEach(f => {
                        const isArr = f._type === 'arr';
                        // æ—¶é—´æ ¼å¼æ”¹ä¸º HH:mm
                        const fullTime = f._time || '--:--:--';
                        const shortTime = fullTime.substring(0, 5); // åªå– HH:mm
                        const tagClass = isArr ? 'tag-arr' : 'tag-dep';
                        // ç®­å¤´å›¾æ ‡ï¼šè¿›æ¸¯ç»¿è‰²å‘ä¸‹ï¼Œå‡ºæ¸¯è“è‰²å‘ä¸Š
                        // ä¿®æ­£ï¼šå‚ç›´å±…ä¸­ (Yè½´åç§»è°ƒæ•´)
                        const arrowIcon = isArr
                            ? '<svg viewBox="0 0 24 24" class="arrow-icon arr"><path d="M12 6v12m0 0l-5-5m5 5l5-5" stroke-linecap="round" stroke-linejoin="round"/></svg>'
                            : '<svg viewBox="0 0 24 24" class="arrow-icon dep"><path d="M12 18V6m0 0l5 5m-5-5l-5 5" stroke-linecap="round" stroke-linejoin="round"/></svg>';

                        const itemTypeClass = isArr ? 'type-arr' : 'type-dep';

                        // æœºå‹æ˜¾ç¤º (ç®€åŒ–æ˜¾ç¤º)
                        const shortAcType = f.aircraftType ? f.aircraftType.replace(/AIRBUS |BOEING |COMAC /g, '') : '--';
                        const airlineCode = f.airline || 'CSN';
                        const currentAcType = f.aircraftType || '';

                        flightListHtml += `
                            <div class="flight-item ${itemTypeClass}" data-index="${f._index}" data-stand="${stand}">
                                <div class="flight-tag ${tagClass}" onmousedown="DragManager.init(this, event)" onmouseup="handleIconUp(this)" onmouseleave="handleIconUp(this)">${arrowIcon}</div>
                                <div class="flight-callsign">${f.callSign || '???'}</div>
                                <div class="flight-actype-trigger ${itemTypeClass}" 
                                     onclick="openAcDropdown(event, ${f._index}, '${airlineCode}', '${currentAcType}')"
                                     onmousedown="event.stopPropagation()">
                                    ${shortAcType}
                                </div>
                                <div class="flight-time">${shortTime}</div>
                            </div>
                        `;
                    });
                }

                card.innerHTML = `
                    <div class="stand-header">
                        <div class="stand-title-group">
                            <button class="stand-toggle-btn" onclick="toggleStandCard('${stand}')">
                                <svg viewBox="0 0 10 10"><path d="M2.5 1.5 Q2 1, 2 1.8 L2 8.2 Q2 9, 2.5 8.5 L7.5 5.5 Q8.2 5, 7.5 4.5 L2.5 1.5 Z" /></svg>
                            </button>
                            <div class="stand-number">åœæœºä½ ${stand}</div>
                        </div>
                        <div class="stand-stats">
                            ${iconsHtml}
                        </div>
                    </div>
                    <div class="stand-body">
                        <div class="stand-list-container">
                            ${flightListHtml}
                        </div>
                    </div>
                `;
                container.appendChild(card);
            });
        }

        function toggleStandCard(stand) {
            const card = document.getElementById(`stand-card-${stand}`);
            if (expandedStands.has(stand)) {
                expandedStands.delete(stand);
                card.classList.remove('expanded');
            } else {
                expandedStands.add(stand);
                card.classList.add('expanded');
            }
        }

        // --- Logic ---
        function parseTime(timeStr) {
            if (!timeStr) return null;
            const parts = timeStr.split(':');
            if (parts.length !== 3) return null;
            return { h: parseInt(parts[0]), m: parseInt(parts[1]), s: parseInt(parts[2]) };
        }
        function formatTime(h, m, s) {
            const pad = (n) => n.toString().padStart(2, '0');
            return `${pad(h)}:${pad(m)}:${pad(s)}`;
        }
        function addMinutes(timeStr, minutesToAdd) {
            const t = parseTime(timeStr);
            if (!t) return timeStr;
            let totalMin = t.h * 60 + t.m + minutesToAdd;
            if (totalMin < 0) totalMin += 24 * 60;
            totalMin = totalMin % (24 * 60);
            return formatTime(Math.floor(totalMin / 60), totalMin % 60, t.s);
        }
        function isValidTimeFormat(str) {
            return /^([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/.test(str);
        }

        // === Unified Flight Type Determination Logic ===
        function getFlightType(f) {
            const offBlock = f.offBlockTime ? f.offBlockTime.trim() : "";
            const takeOff = f.takeOffTime ? f.takeOffTime.trim() : "";
            const landing = f.landingTime ? f.landingTime.trim() : "";
            const inBlock = f.inBlockTime ? f.inBlockTime.trim() : "";

            // è®¡ç®—åˆ°è¾¾å’Œå‡ºå‘æ—¶é—´çš„å®Œæ•´åº¦
            const hasArrivalTimes = landing || inBlock;
            const hasDepartureTimes = offBlock || takeOff;

            // 1. åªæœ‰å‡ºå‘æ—¶é—´ -> å‡ºå‘èˆªç­
            if (hasDepartureTimes && !hasArrivalTimes) return 'departure';
            // 2. åªæœ‰åˆ°è¾¾æ—¶é—´ -> åˆ°è¾¾èˆªç­
            if (hasArrivalTimes && !hasDepartureTimes) return 'arrival';
            // 3. ä¸¤è€…éƒ½æœ‰ -> æ ¹æ®æ—¶é—´æ•°é‡å’Œä¸»è¦æ—¶é—´åˆ¤æ–­
            if (hasArrivalTimes && hasDepartureTimes) {
                const arrCount = (landing ? 1 : 0) + (inBlock ? 1 : 0);
                const depCount = (offBlock ? 1 : 0) + (takeOff ? 1 : 0);
                // å“ªè¾¹æ—¶é—´æ›´å®Œæ•´å°±è®¤å®šä¸ºå“ªç§ç±»å‹
                if (depCount > arrCount) return 'departure';
                if (arrCount > depCount) return 'arrival';
                // æ•°é‡ç›¸åŒæ—¶ï¼Œä¼˜å…ˆçœ‹ landingTimeï¼ˆé€šå¸¸åˆ°è¾¾èˆªç­å…ˆå¡« landingï¼‰
                if (landing) return 'arrival';
                return 'departure';
            }

            // 4. Airport Code based (Fallback for drafts)
            if (isAirportLocked && currentAirportCode) {
                if (f.arrival === currentAirportCode) return 'arrival';
                if (f.departure === currentAirportCode) return 'departure';
            }

            // 5. Default fallback
            return 'arrival';
        }

        function handleTimeKeyDown(e, input, index, key) {
            if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'PageUp' || e.key === 'PageDown') {
                e.preventDefault();
                let delta = 0;
                if (e.key === 'ArrowUp') delta = 1;
                if (e.key === 'ArrowDown') delta = -1;
                if (e.key === 'PageUp') delta = 10;
                if (e.key === 'PageDown') delta = -10;

                const currentVal = input.value;
                if (!isValidTimeFormat(currentVal)) return;

                const newVal = addMinutes(currentVal, delta);
                input.value = newVal;
                updateFlight(index, key, newVal);
                triggerAutoCalc(index, key, newVal);
                renderTable(); // é‡æ–°æ¸²æŸ“ä»¥æ›´æ–°å†²çªæ£€æµ‹
            }
        }

        // ===== æ‹–æ‹½ç®¡ç†å™¨ (DragManager) =====
        const DragManager = {
            isDragging: false,
            dragThreshold: 5,
            startX: 0,
            startY: 0,
            sourceEl: null,
            ghostEl: null,
            flightItemEl: null,
            sourceIndex: -1,
            sourceStand: null,
            currentOverCard: null,

            init(tagEl, e) {
                if (e.button !== 0) return; // åªå“åº”å·¦é”®

                // è·å– flight-item çˆ¶å…ƒç´ 
                this.flightItemEl = tagEl.closest('.flight-item');
                if (!this.flightItemEl) return;

                this.sourceIndex = parseInt(this.flightItemEl.dataset.index);
                this.sourceStand = this.flightItemEl.dataset.stand;
                this.startX = e.clientX;
                this.startY = e.clientY;

                // æ·»åŠ æŒ‰ä¸‹æ•ˆæœ
                tagEl.classList.add('pressed');

                // ç»‘å®šå…¨å±€äº‹ä»¶
                document.addEventListener('mousemove', this._onMouseMove);
                document.addEventListener('mouseup', this._onMouseUp);
            },

            _onMouseMove: (e) => {
                const dm = DragManager;
                const dx = e.clientX - dm.startX;
                const dy = e.clientY - dm.startY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (!dm.isDragging && dist > dm.dragThreshold) {
                    dm._startDrag(e);
                }

                if (dm.isDragging) {
                    dm._updateGhostPosition(e);
                    dm._updateDropTarget(e);
                }
            },

            _onMouseUp: (e) => {
                const dm = DragManager;

                if (dm.isDragging) {
                    dm._endDrag(e);
                }

                dm._cleanup();
            },

            _startDrag(e) {
                this.isDragging = true;
                document.body.classList.add('is-dragging');

                // åˆ›å»º Ghost å…ƒç´ 
                const rect = this.flightItemEl.getBoundingClientRect();
                this.ghostEl = this.flightItemEl.cloneNode(true);
                this.ghostEl.classList.add('drag-ghost');
                this.ghostEl.classList.remove('dragging');
                this.ghostEl.style.width = rect.width + 'px';
                this.ghostEl.style.left = (e.clientX - rect.width / 2) + 'px';
                this.ghostEl.style.top = (e.clientY - 20) + 'px';
                document.body.appendChild(this.ghostEl);

                // è·å–æºåœæœºä½çš„åˆ—è¡¨å®¹å™¨
                const sourceCard = document.getElementById(`stand-card-${this.sourceStand}`);
                this.sourceListContainer = sourceCard?.querySelector('.stand-list-container');

                if (this.sourceListContainer) {
                    // ä¿å­˜ä¸‹ä¸€ä¸ªå…„å¼ŸèŠ‚ç‚¹ï¼Œç”¨äºæ¢å¤ä½ç½®
                    this.sourceNextSibling = this.flightItemEl.nextElementSibling;

                    // é”å®šå½“å‰é«˜åº¦
                    const currentHeight = this.sourceListContainer.offsetHeight;
                    this.sourceListContainer.style.height = currentHeight + 'px';
                    this.sourceListContainer.style.overflow = 'hidden';

                    // ç§»é™¤æºå…ƒç´ ï¼ˆä» DOM ä¸­ï¼‰
                    this.flightItemEl.remove();

                    // è®¡ç®—ç§»é™¤åçš„æ–°é«˜åº¦å¹¶è§¦å‘åŠ¨ç”»ï¼ˆæ”¶ç¼© - å¹³æ»‘æ— å›å¼¹ï¼‰
                    requestAnimationFrame(() => {
                        this.sourceListContainer.classList.add('anim-shrink'); // æ·»åŠ æ”¶ç¼©åŠ¨ç”»ç±»
                        const newHeight = this.sourceListContainer.scrollHeight;
                        this.sourceListContainer.style.height = newHeight + 'px';

                        // åŠ¨ç”»ç»“æŸåæ¸…ç†
                        setTimeout(() => {
                            if (this.sourceListContainer) {
                                this.sourceListContainer.classList.remove('anim-shrink');
                                this.sourceListContainer.style.height = '';
                                this.sourceListContainer.style.overflow = '';
                            }
                        }, 400);
                    });
                } else {
                    // å¤‡é€‰æ–¹æ¡ˆï¼šæ ‡è®°ä¸ºæ‹–æ‹½ä¸­
                    this.flightItemEl.classList.add('dragging');
                }
            },

            _updateGhostPosition(e) {
                if (!this.ghostEl) return;
                const rect = this.ghostEl.getBoundingClientRect();
                this.ghostEl.style.left = (e.clientX - rect.width / 2) + 'px';
                this.ghostEl.style.top = (e.clientY - 20) + 'px';
            },

            // æ£€æµ‹å°†èˆªç­æ”¾ç½®åˆ°ç›®æ ‡åœæœºä½æ˜¯å¦ä¼šé€ æˆå†²çª
            _wouldCauseConflict(targetStand) {
                const flight = allFlights[this.sourceIndex];
                if (!flight) return false;

                const flightType = getFlightType(flight);

                // è·å–ç›®æ ‡åœæœºä½ç°æœ‰èˆªç­ï¼ˆæ’é™¤æ­£åœ¨æ‹–æ‹½çš„èˆªç­ï¼‰
                const flightsInTarget = allFlights.filter(f =>
                    f.stand === targetStand && allFlights.indexOf(f) !== this.sourceIndex
                );

                const arrivalsInTarget = flightsInTarget.filter(f => getFlightType(f) === 'arrival');
                const departuresInTarget = flightsInTarget.filter(f => getFlightType(f) === 'departure');

                // è§„åˆ™1: å¤šåˆ°è¾¾å†²çª - å¦‚æœæˆ‘æ˜¯åˆ°è¾¾èˆªç­ï¼Œä¸”ç›®æ ‡å·²æœ‰åˆ°è¾¾èˆªç­
                if (flightType === 'arrival' && arrivalsInTarget.length >= 1) {
                    return true;
                }

                // è§„åˆ™2: æ—¶é—´äº¤å‰å†²çª
                if (flightType === 'arrival') {
                    // æˆ‘æ˜¯åˆ°è¾¾èˆªç­ï¼Œæ£€æŸ¥ä¸ç°æœ‰å‡ºå‘èˆªç­çš„æ—¶é—´å…³ç³»
                    const myInBlock = flight.inBlockTime || flight.landingTime;
                    for (const dep of departuresInTarget) {
                        const depTakeOff = dep.takeOffTime || dep.offBlockTime;
                        if (myInBlock && depTakeOff && compareTime(myInBlock, depTakeOff) <= 0) {
                            return true;
                        }
                    }
                } else {
                    // æˆ‘æ˜¯å‡ºå‘èˆªç­ï¼Œæ£€æŸ¥ä¸ç°æœ‰åˆ°è¾¾èˆªç­çš„æ—¶é—´å…³ç³»
                    const myTakeOff = flight.takeOffTime || flight.offBlockTime;
                    for (const arr of arrivalsInTarget) {
                        const arrInBlock = arr.inBlockTime || arr.landingTime;
                        if (arrInBlock && myTakeOff && compareTime(arrInBlock, myTakeOff) <= 0) {
                            return true;
                        }
                    }
                }

                return false;
            },

            _updateDropTarget(e) {
                // ä¸´æ—¶éšè— ghost ä»¥æ£€æµ‹ä¸‹æ–¹å…ƒç´ 
                if (this.ghostEl) this.ghostEl.style.display = 'none';
                const elBelow = document.elementFromPoint(e.clientX, e.clientY);
                if (this.ghostEl) this.ghostEl.style.display = '';

                const standCard = elBelow?.closest('.stand-card');

                // ç§»é™¤æ—§é«˜äº®
                if (this.currentOverCard && this.currentOverCard !== standCard) {
                    this.currentOverCard.classList.remove('drag-over', 'drag-over-invalid');
                }

                // æ·»åŠ æ–°é«˜äº®
                if (standCard && standCard.id !== `stand-card-${this.sourceStand}`) {
                    const targetStand = standCard.id.replace('stand-card-', '');
                    const isInvalid = this._wouldCauseConflict(targetStand);

                    standCard.classList.remove('drag-over', 'drag-over-invalid');
                    standCard.classList.add(isInvalid ? 'drag-over-invalid' : 'drag-over');
                    this.currentOverCard = standCard;
                } else {
                    this.currentOverCard = null;
                }
            },

            _endDrag(e) {
                // ä¸´æ—¶éšè— ghost ä»¥æ£€æµ‹ä¸‹æ–¹å…ƒç´ 
                if (this.ghostEl) this.ghostEl.style.display = 'none';
                const elBelow = document.elementFromPoint(e.clientX, e.clientY);
                if (this.ghostEl) this.ghostEl.style.display = '';

                const targetCard = elBelow?.closest('.stand-card');

                if (targetCard && targetCard.id !== `stand-card-${this.sourceStand}`) {
                    // æå–ç›®æ ‡åœæœºä½
                    const targetStand = targetCard.id.replace('stand-card-', '');

                    // æ›´æ–°æ•°æ®
                    if (this.sourceIndex >= 0 && this.sourceIndex < allFlights.length) {
                        allFlights[this.sourceIndex].stand = targetStand;

                        // è·å–ç›®æ ‡å¡ç‰‡å®¹å™¨ç”¨äºæ‰©å¼ åŠ¨ç”» - è®°å½•æ—§é«˜åº¦
                        const targetListContainer = targetCard.querySelector('.stand-list-container');
                        const oldHeight = targetListContainer ? targetListContainer.offsetHeight : 0;

                        // åˆ·æ–°è§†å›¾
                        renderTable();

                        // è§¦å‘ç›®æ ‡å¡ç‰‡æ‰©å¼ åŠ¨ç”»ï¼ˆå›å¼¹ï¼‰
                        const newTargetCard = document.getElementById(`stand-card-${targetStand}`);
                        const newTargetContainer = newTargetCard?.querySelector('.stand-list-container');
                        if (newTargetContainer) {
                            // ç«‹å³é”å®šä¸ºæ—§é«˜åº¦ï¼ˆåŠ¨ç”»èµ·ç‚¹ï¼‰
                            const targetHeight = newTargetContainer.scrollHeight;
                            newTargetContainer.style.height = oldHeight + 'px';
                            newTargetContainer.style.overflow = 'hidden';

                            // ä¸‹ä¸€å¸§è¿‡æ¸¡åˆ°æ–°é«˜åº¦
                            requestAnimationFrame(() => {
                                newTargetContainer.classList.add('anim-expand'); // æ·»åŠ æ‰©å¼ åŠ¨ç”»ç±»
                                newTargetContainer.style.height = targetHeight + 'px';
                                setTimeout(() => {
                                    newTargetContainer.classList.remove('anim-expand');
                                    newTargetContainer.style.height = '';
                                    newTargetContainer.style.overflow = '';
                                }, 450); // æ—¶é—´ç•¥é•¿äº 0.4s
                            });
                        }

                        showStatus(`å·²å°†èˆªç­ç§»åŠ¨åˆ°åœæœºä½ ${targetStand}`);
                    }
                } else {
                    // å–æ¶ˆæ‹–æ‹½ï¼Œæ¢å¤æºå¡ç‰‡
                    this._revertToSource();
                }
            },

            _revertToSource() {
                // æ¢å¤æºå¡ç‰‡ï¼šé‡æ–°æ·»åŠ å…ƒç´ å¹¶åŠ¨ç”»
                const sourceCard = document.getElementById(`stand-card-${this.sourceStand}`);
                const sourceListContainer = sourceCard?.querySelector('.stand-list-container');

                if (sourceListContainer && this.ghostEl) {
                    // é”å®šå½“å‰é«˜åº¦
                    const currentHeight = sourceListContainer.offsetHeight;
                    sourceListContainer.style.height = currentHeight + 'px';
                    sourceListContainer.style.overflow = 'hidden';

                    // åˆ›å»ºæ¢å¤çš„å…ƒç´ 
                    const restoredEl = this.ghostEl.cloneNode(true);
                    restoredEl.classList.remove('drag-ghost');
                    restoredEl.style = ''; // æ¸…é™¤ fixed å®šä½æ ·å¼

                    // æ·»åŠ åˆ°å®¹å™¨ï¼ˆæ¢å¤åˆ°åŸä½ç½®ï¼‰
                    if (this.sourceNextSibling) {
                        sourceListContainer.insertBefore(restoredEl, this.sourceNextSibling);
                    } else {
                        sourceListContainer.appendChild(restoredEl);
                    }

                    // è§¦å‘æ‰©å¼ åŠ¨ç”»ï¼ˆæ¢å¤ - å›å¼¹ï¼‰
                    requestAnimationFrame(() => {
                        sourceListContainer.classList.add('anim-expand'); // æ·»åŠ æ‰©å¼ åŠ¨ç”»ç±»
                        const newHeight = sourceListContainer.scrollHeight;
                        sourceListContainer.style.height = newHeight + 'px';

                        setTimeout(() => {
                            sourceListContainer.classList.remove('anim-expand');
                            sourceListContainer.style.height = '';
                            sourceListContainer.style.overflow = '';
                            // å®Œæˆååˆ·æ–°è§†å›¾ç¡®ä¿æ•°æ®ä¸€è‡´
                            renderTable();
                        }, 450);
                    });
                } else {
                    // å¤‡é€‰ï¼šç›´æ¥åˆ·æ–°
                    renderTable();
                }
            },

            _cleanup() {
                // ç§»é™¤ Ghost
                if (this.ghostEl) {
                    this.ghostEl.remove();
                    this.ghostEl = null;
                }

                // ç§»é™¤é«˜äº®
                if (this.currentOverCard) {
                    this.currentOverCard.classList.remove('drag-over', 'drag-over-invalid');
                    this.currentOverCard = null;
                }

                // ç§»é™¤æºå…ƒç´ æ‹–æ‹½çŠ¶æ€
                if (this.flightItemEl) {
                    this.flightItemEl.querySelector('.flight-tag')?.classList.remove('pressed');
                    this.flightItemEl = null;
                }

                // ç§»é™¤ body æ ·å¼
                document.body.classList.remove('is-dragging');

                // è§£ç»‘äº‹ä»¶
                document.removeEventListener('mousemove', this._onMouseMove);
                document.removeEventListener('mouseup', this._onMouseUp);

                // é‡ç½®çŠ¶æ€
                this.isDragging = false;
                this.sourceIndex = -1;
                this.sourceStand = null;
            }
        };

        // === Custom Dropdown Manager ===
        const CustomDropdownManager = {
            activeDropdown: null,
            activeTrigger: null,

            init() {
                // Close on click outside
                document.addEventListener('mousedown', (e) => {
                    if (this.activeDropdown &&
                        !this.activeDropdown.contains(e.target) &&
                        !this.activeTrigger.contains(e.target)) {
                        this.close();
                    }
                });
                // Close on resize/scroll to prevent drift
                window.addEventListener('resize', () => this.close());
                window.addEventListener('scroll', () => this.close(), true);
            },

            open(triggerEl, options, callback, typeClass) {
                if (this.activeDropdown) this.close();

                this.activeTrigger = triggerEl;
                const rect = triggerEl.getBoundingClientRect();

                // Create container
                const dropdown = document.createElement('div');
                dropdown.className = `custom-dropdown ${typeClass}`;

                // Populate options
                options.forEach(opt => {
                    const item = document.createElement('div');
                    item.className = `custom-dropdown-item ${opt.selected ? 'selected' : ''} ${typeClass}`;
                    item.textContent = opt.label;
                    item.onclick = (e) => {
                        e.stopPropagation(); // Stop propagation to avoid document click closing it immediately
                        callback(opt.value);
                        this.close();
                    };
                    dropdown.appendChild(item);
                });

                document.body.appendChild(dropdown);
                this.activeDropdown = dropdown;

                // Positioning logic
                // Default: below, left aligned
                let top = rect.bottom + 4;
                let left = rect.left;

                // If overflowing bottom, flip to above
                if (top + dropdown.offsetHeight > window.innerHeight - 10) {
                    top = rect.top - dropdown.offsetHeight - 4;
                }

                // If overflowing right
                if (left + dropdown.offsetWidth > window.innerWidth) {
                    left = window.innerWidth - dropdown.offsetWidth - 10;
                }

                dropdown.style.top = top + 'px';
                dropdown.style.left = left + 'px';
                dropdown.style.minWidth = Math.max(120, rect.width) + 'px';

                // Scroll selected into view
                const selected = dropdown.querySelector('.selected');
                if (selected) {
                    selected.scrollIntoView({ block: 'center', behavior: 'auto' });
                }
            },

            close() {
                if (this.activeDropdown) {
                    this.activeDropdown.remove();
                    this.activeDropdown = null;
                    this.activeTrigger = null;
                }
            }
        };

        // Helper to open dropdown from flight item
        function openAcDropdown(event, index, airline, currentType) {
            event.preventDefault();
            event.stopPropagation();

            const trigger = event.currentTarget; // Use currentTarget to get the div

            // Get available types
            let availableTypes = config.mapping.airlineToAircrafts[airline] || config.aircraftTypes;
            if (currentType && !availableTypes.includes(currentType)) {
                availableTypes = [...availableTypes, currentType];
            }

            // Map to options
            const options = availableTypes.map(t => ({
                label: t.replace(/AIRBUS |BOEING |COMAC /g, ''),
                value: t,
                selected: t === currentType
            }));

            const typeClass = trigger.classList.contains('type-arr') ? 'type-arr' : 'type-dep';

            CustomDropdownManager.open(trigger, options, (val) => {
                updateFlightAircraft(index, val);
            }, typeClass);
        }

        // Initialize on load
        window.addEventListener('load', () => CustomDropdownManager.init());

        // å¤„ç†å›¾æ ‡æŒ‰ä¸‹ï¼ˆéæ‹–æ‹½åœºæ™¯ï¼Œä¿ç•™å…¼å®¹ï¼‰
        function handleIconDown(el, event) {
            // ä»…å“åº”é¼ æ ‡å·¦é”® (button 0)
            if (event.button === 0) {
                el.classList.add('pressed');
            }
        }

        // å¤„ç†å›¾æ ‡é‡Šæ”¾ï¼ˆæ¾å¼€æˆ–ç¦»å¼€ï¼‰
        function handleIconUp(el) {
            el.classList.remove('pressed');
        }

        function handleTimeBlur(e, originalValue, index, key) {
            const val = e.target.value.trim();
            if (val === "") return;
            if (!isValidTimeFormat(val)) {
                showAlertModal("è¯·è¾“å…¥æ­£ç¡®çš„24å°æ—¶åˆ¶æ—¶é—´æ ¼å¼ï¼(HH:mm:ss)", 'warning');
                e.target.value = originalValue;
            } else {
                updateFlight(index, key, val);
                triggerAutoCalc(index, key, val);
                renderTable(); // é‡æ–°æ¸²æŸ“ä»¥æ›´æ–°å†²çªæ£€æµ‹
            }
        }
        function handleOffsetChange(e) {
            const val = parseInt(e.target.value);
            if (isNaN(val)) return;
            timeOffsets[currentTab] = val;
            const baseKey = currentTab === 'arrival' ? 'landingTime' : 'offBlockTime';
            const targetKey = currentTab === 'arrival' ? 'inBlockTime' : 'takeOffTime';
            allFlights.forEach((f, idx) => {
                const type = getFlightType(f);
                const visible = currentTab === 'arrival' ? (type === 'arrival') : (type === 'departure');
                if (currentTab !== 'all' && visible && f[baseKey]) {
                    f[targetKey] = addMinutes(f[baseKey], val);
                }
            });
            renderTable();
        }
        function triggerAutoCalc(index, changedKey, newVal) {
            if (currentTab === 'all') return;
            const offset = timeOffsets[currentTab];
            if (!offset && offset !== 0) return;
            let targetKey = null;
            if (currentTab === 'arrival' && changedKey === 'landingTime') targetKey = 'inBlockTime';
            if (currentTab === 'departure' && changedKey === 'offBlockTime') targetKey = 'takeOffTime';
            if (targetKey) {
                const calcVal = addMinutes(newVal, offset);
                allFlights[index][targetKey] = calcVal;
                const inputs = document.querySelectorAll(`input[data-row="${index}"][data-key="${targetKey}"]`);
                if (inputs.length > 0) inputs[0].value = calcVal;
            }
        }

        // --- Selection & Batch Logic ---
        function getFilteredFlights() {
            let result = allFlights.map((f, index) => ({ flight: f, index: index }))
                .filter(item => {
                    const f = item.flight;

                    // 1. Tab Type Check
                    if (currentTab === 'all') return true;
                    const type = getFlightType(f);
                    if (currentTab !== type) return false;

                    // 2. Strict Location Filter (New)
                    if (isAirportLocked && currentAirportCode) {
                        if (currentTab === 'arrival' && f.arrival !== currentAirportCode) return false;
                        if (currentTab === 'departure' && f.departure !== currentAirportCode) return false;
                    }

                    return true;
                });

            // å…¨éƒ¨èˆªç­è§†å›¾ï¼šæŒ‰æ—¶é—´å‡åºæ’åº
            if (currentTab === 'all') {
                result.sort((a, b) => {
                    // è·å–å„èˆªç­çš„å…³é”®æ—¶é—´ï¼ˆç€é™†æ—¶é—´æˆ–æ¨å‡ºæ—¶é—´ï¼Œå–è¾ƒæ—©çš„ï¼‰
                    const getTime = (f) => f.landingTime || f.offBlockTime || '';
                    const timeA = getTime(a.flight);
                    const timeB = getTime(b.flight);
                    return timeA.localeCompare(timeB);
                });
            }

            return result;
        }

        function handleRowSelection(e, dataIndex, visualIndex) {
            if (e.button === 0) {
                if (e.shiftKey) {
                    if (lastVisualIndex !== null) {
                        const start = Math.min(lastVisualIndex, visualIndex);
                        const end = Math.max(lastVisualIndex, visualIndex);
                        const currentFiltered = getFilteredFlights();
                        for (let i = start; i <= end; i++) {
                            if (currentFiltered[i]) {
                                selectedIndices.add(currentFiltered[i].index);
                            }
                        }
                    } else {
                        selectedIndices.add(dataIndex);
                    }
                } else if (e.ctrlKey || e.metaKey) {
                    if (selectedIndices.has(dataIndex)) selectedIndices.delete(dataIndex);
                    else selectedIndices.add(dataIndex);
                    lastVisualIndex = visualIndex;
                } else {
                    selectedIndices.clear();
                    selectedIndices.add(dataIndex);
                    lastVisualIndex = visualIndex;
                }
            } else if (e.button === 2) {
                if (e.shiftKey) {
                    selectedIndices.delete(dataIndex);
                    e.preventDefault();
                }
            }
            updateSelectionVisuals();
        }

        function updateSelectionVisuals() {
            document.querySelectorAll('#tableBody tr').forEach(tr => {
                const idx = parseInt(tr.dataset.index);
                if (selectedIndices.has(idx)) tr.classList.add('selected-row');
                else tr.classList.remove('selected-row');
            });
            updateSelectionInfo(); // æ›´æ–°çŠ¶æ€æ é€‰ä¸­æ•°
        }

        function updateBatchButtons() {
            const btnSetArr = document.getElementById('btnSetArr');
            const btnSetDep = document.getElementById('btnSetDep');
            const enabled = isAirportLocked && currentAirportCode !== "";

            btnSetArr.disabled = !enabled;
            btnSetDep.disabled = !enabled;

            if (enabled) {
                btnSetArr.title = `å°†é€‰ä¸­è¡Œè½¬æ¢ä¸ºåˆ°è¾¾èˆªç­ (${currentAirportCode})`;
                btnSetDep.title = `å°†é€‰ä¸­è¡Œè½¬æ¢ä¸ºå‡ºå‘èˆªç­ (${currentAirportCode})`;
            } else {
                btnSetArr.title = "éœ€é”å®šå½“å‰æœºåœº";
                btnSetDep.title = "éœ€é”å®šå½“å‰æœºåœº";
            }
        }

        // === Fixed Logic: Force Overwrite & Robust Swap ===
        async function batchSetAsArrival() {
            const freshCode = document.getElementById('airportCode').value.trim().toUpperCase();
            if (!isAirportLocked || !freshCode) return;
            if (selectedIndices.size === 0) { await showAlertModal("è¯·å…ˆé€‰æ‹©è‡³å°‘ä¸€è¡Œ", 'warning'); return; }

            let count = 0;
            selectedIndices.forEach(idx => {
                const f = allFlights[idx];
                if (!f) return;

                const oldArr = f.arrival;
                f.arrival = freshCode;

                if (f.departure === freshCode) {
                    f.departure = (oldArr && oldArr !== freshCode) ? oldArr : "ZBAA";
                }

                if (f.offBlockTime && !f.landingTime) {
                    f.landingTime = f.offBlockTime;
                    f.offBlockTime = "";
                    f.takeOffTime = "";
                    const offset = timeOffsets['arrival'] || 10;
                    f.inBlockTime = addMinutes(f.landingTime, offset);
                }
                else if (f.landingTime) {
                    f.offBlockTime = "";
                    f.takeOffTime = "";
                }
                else {
                    f.offBlockTime = "";
                    f.takeOffTime = "";
                }
                count++;
            });
            renderTable();
            updateStats();
            showStatus(`å·²å°† ${count} æ¡è®°å½•è½¬æ¢ä¸ºåˆ°è¾¾èˆªç­`);
        }

        async function batchSetAsDeparture() {
            const freshCode = document.getElementById('airportCode').value.trim().toUpperCase();
            if (!isAirportLocked || !freshCode) return;
            if (selectedIndices.size === 0) { await showAlertModal("è¯·å…ˆé€‰æ‹©è‡³å°‘ä¸€è¡Œ", 'warning'); return; }

            let count = 0;
            selectedIndices.forEach(idx => {
                const f = allFlights[idx];
                if (!f) return;

                const oldDep = f.departure;
                f.departure = freshCode;

                if (f.arrival === freshCode) {
                    f.arrival = (oldDep && oldDep !== freshCode) ? oldDep : "ZBAA";
                }

                if (f.landingTime && !f.offBlockTime) {
                    f.offBlockTime = f.landingTime;
                    f.landingTime = "";
                    f.inBlockTime = "";
                    const offset = timeOffsets['departure'] || 10;
                    f.takeOffTime = addMinutes(f.offBlockTime, offset);
                }
                else if (f.offBlockTime) {
                    f.landingTime = "";
                    f.inBlockTime = "";
                }
                else {
                    f.landingTime = "";
                    f.inBlockTime = "";
                }
                count++;
            });
            renderTable();
            updateStats();
            showStatus(`å·²å°† ${count} æ¡è®°å½•è½¬æ¢ä¸ºå‡ºå‘èˆªç­`);
        }

        async function toggleAirportLock() {
            const input = document.getElementById('airportCode');
            const btn = document.getElementById('btnLock');
            if (!isAirportLocked) {
                const code = input.value.trim().toUpperCase();
                if (!code) { await showAlertModal("è¯·è¾“å…¥æœºåœºä»£å·", 'warning'); return; }
                currentAirportCode = code;
                isAirportLocked = true;
                input.value = code;
                input.disabled = true;
                btn.innerHTML = "ğŸ”’ è§£é”";
                btn.classList.add("active-lock");
            } else {
                isAirportLocked = false;
                input.disabled = false;
                btn.innerHTML = "ğŸ”“ é”å®š";
                btn.classList.remove("active-lock");
            }
            updateBatchButtons();
            renderTable();
        }

        async function deduplicateCallsigns() {
            const usedCallsigns = new Set(allFlights.map(f => f.callSign).filter(c => c));
            const seenThisRun = new Set();
            let changes = 0;
            allFlights.forEach(f => {
                if (!f.callSign) return;
                if (seenThisRun.has(f.callSign)) {
                    const airline = f.airline;
                    const available = config.mapping.airlineToCallsigns[airline] || [];
                    const candidate = available.find(c => !usedCallsigns.has(c));
                    if (candidate) {
                        f.callSign = candidate;
                        usedCallsigns.add(candidate);
                        changes++;
                    }
                } else {
                    seenThisRun.add(f.callSign);
                }
            });
            if (changes > 0) {
                renderTable();
                updateStats();
                await showAlertModal(`å·²è‡ªåŠ¨ä¿®å¤ ${changes} ä¸ªé‡å¤å‘¼å·`, 'success');
            } else {
                await showAlertModal("æœªå‘ç°å¯ä¿®å¤çš„é‡å¤å‘¼å· (æˆ–æ— å¯ç”¨æ›¿ä»£)", 'info');
            }
        }

        function highlightDuplicates(callsign) {
            if (!callsign) return;
            document.querySelectorAll(`tr[data-callsign="${callsign}"]`).forEach(el => el.classList.add('highlight-group'));
        }
        function unhighlightDuplicates(callsign) {
            if (!callsign) return;
            document.querySelectorAll(`tr[data-callsign="${callsign}"]`).forEach(el => el.classList.remove('highlight-group'));
        }

        // === åœæœºä½å†²çªæ£€æµ‹ ===
        function compareTime(time1, time2) {
            // è¿”å›è´Ÿæ•°è¡¨ç¤º time1 < time2ï¼Œ0 è¡¨ç¤ºç›¸ç­‰ï¼Œæ­£æ•°è¡¨ç¤º time1 > time2
            const t1 = parseTime(time1);
            const t2 = parseTime(time2);
            if (!t1 || !t2) return 0;
            const mins1 = t1.h * 60 + t1.m;
            const mins2 = t2.h * 60 + t2.m;
            return mins1 - mins2;
        }

        function detectStandConflicts() {
            const conflicts = new Map(); // stand -> Set of conflicting flight indices
            const standFlights = new Map(); // stand -> { arrivals: [], departures: [] }

            // 1. æŒ‰åœæœºä½åˆ†ç»„èˆªç­
            allFlights.forEach((f, idx) => {
                if (!f.stand) return;
                if (!standFlights.has(f.stand)) {
                    standFlights.set(f.stand, { arrivals: [], departures: [] });
                }
                const type = getFlightType(f);
                if (type === 'arrival') {
                    standFlights.get(f.stand).arrivals.push({ flight: f, index: idx });
                } else {
                    standFlights.get(f.stand).departures.push({ flight: f, index: idx });
                }
            });

            // 2. æ£€æµ‹å†²çª
            standFlights.forEach((data, stand) => {
                const conflictIndices = new Set();

                // è§„åˆ™2: å¤šåˆ°è¾¾å†²çª (â‰¥2 ä¸ªåˆ°è¾¾èˆªç­)
                if (data.arrivals.length >= 2) {
                    data.arrivals.forEach(a => conflictIndices.add(a.index));
                }

                // è§„åˆ™1: åˆ°è¾¾-å‡ºå‘å†²çª
                data.arrivals.forEach(arr => {
                    data.departures.forEach(dep => {
                        // ä½¿ç”¨ landingTime (ä¸»æ•°æ®)ï¼Œå¦‚æœæ²¡æœ‰åˆ™ç”¨ inBlockTime ä½œä¸ºå¤‡é€‰
                        const arrTime = arr.flight.landingTime || arr.flight.inBlockTime;
                        // ä½¿ç”¨ offBlockTime (ä¸»æ•°æ®)ï¼Œå¦‚æœæ²¡æœ‰åˆ™ç”¨ takeOffTime ä½œä¸ºå¤‡é€‰
                        const depTime = dep.flight.offBlockTime || dep.flight.takeOffTime;
                        // å†²çªæ¡ä»¶ï¼šåˆ°è¾¾ç€é™†æ—¶é—´ >= å‡ºå‘æ¨å‡ºæ—¶é—´ï¼ˆå…ˆå‡ºåè¿›ï¼šå‡ºå‘è¿˜æ²¡ç¦»å¼€ï¼Œåˆ°è¾¾å·²ç€é™†ï¼‰
                        if (arrTime && depTime && compareTime(arrTime, depTime) <= 0) {
                            conflictIndices.add(arr.index);
                            conflictIndices.add(dep.index);
                        }
                    });
                });

                if (conflictIndices.size > 0) {
                    conflicts.set(stand, conflictIndices);
                }
            });

            return conflicts;
        }

        function highlightConflicts(stand) {
            if (!stand) return;
            document.querySelectorAll(`tr[data-conflict-stand="${stand}"]`).forEach(el => {
                el.classList.add('highlight-conflict');
            });
        }

        function unhighlightConflicts(stand) {
            if (!stand) return;
            document.querySelectorAll(`tr[data-conflict-stand="${stand}"]`).forEach(el => {
                el.classList.remove('highlight-conflict');
            });
        }

        function updateStats() {
            let arrCount = 0; let depCount = 0;
            allFlights.forEach(f => {
                const type = getFlightType(f);
                if (type === 'arrival') arrCount++; else depCount++;
            });
            document.getElementById('statsInfo').innerText = `æ€»è®¡: ${allFlights.length} | åˆ°è¾¾: ${arrCount} | å‡ºå‘: ${depCount}`;
        }

        function updateSelectionInfo() {
            const count = selectedIndices.size;
            const el = document.getElementById('selectionInfo');
            el.textContent = count > 0 ? `å·²é€‰ä¸­ ${count} æ¡èˆªç­è®°å½•` : '';
        }
        function showStatus(msg) {
            document.getElementById('statusMsg').innerText = msg;
            setTimeout(() => document.getElementById('statusMsg').innerText = 'å°±ç»ª', 3000);
        }

        // --- Rendering ---
        function renderHeader() {
            const tr = document.getElementById('headerRow');
            tr.innerHTML = '';
            headers.forEach(h => {
                if (currentTab === 'all') {
                    if (h.key === 'takeOffTime' || h.key === 'inBlockTime') return;
                } else {
                    if (h.tab && h.tab !== currentTab) return;
                }
                const th = document.createElement('th');
                const container = document.createElement('div');
                container.style.display = 'flex';
                container.style.alignItems = 'center';
                container.innerText = h.label;

                // å‘¼å·åˆ—æ·»åŠ éšæœºæ’åˆ—æŒ‰é’®ï¼ˆä»…åœ¨åˆ°è¾¾/å‡ºå‘è§†å›¾ï¼‰
                if (h.key === 'callSign' && currentTab !== 'all') {
                    const shuffleBtn = document.createElement('button');
                    shuffleBtn.innerHTML = 'ğŸ”€';
                    shuffleBtn.className = 'header-btn';
                    shuffleBtn.style.cssText = 'margin-left: 8px; padding: 2px 6px; font-size: 0.9em; cursor: pointer; background: transparent; border: 1px solid #555; border-radius: 4px;';
                    shuffleBtn.title = 'éšæœºæ’åˆ—å½“å‰è§†å›¾çš„èˆªç­';
                    shuffleBtn.onclick = shuffleFlights;
                    container.appendChild(shuffleBtn);
                }

                // åœæœºä½åˆ—æ·»åŠ æ¸…ç©ºæŒ‰é’®
                if (h.key === 'stand') {
                    const clearBtn = document.createElement('button');
                    clearBtn.innerHTML = 'ğŸ—‘ï¸';
                    clearBtn.className = 'header-btn';
                    clearBtn.style.cssText = 'margin-left: 8px; padding: 2px 6px; font-size: 0.9em; cursor: pointer; background: transparent; border: 1px solid #555; border-radius: 4px;';
                    clearBtn.title = 'æ¸…ç©ºå½“å‰è§†å›¾èˆªç­çš„åœæœºä½';
                    clearBtn.onclick = clearStands;
                    container.appendChild(clearBtn);
                }

                if (h.hasOffset && currentTab !== 'all') {
                    const offsetInput = document.createElement('input');
                    offsetInput.type = 'number';
                    offsetInput.className = 'header-offset';
                    offsetInput.placeholder = '+min';
                    offsetInput.value = timeOffsets[currentTab] || '';
                    offsetInput.onchange = handleOffsetChange;
                    offsetInput.title = "è¾“å…¥å¢åŠ çš„åˆ†é’Ÿæ•°ï¼Œè‡ªåŠ¨è®¡ç®—è¯¥åˆ—æ—¶é—´";
                    container.appendChild(offsetInput);
                }

                // æ—¶é—´åˆ—æ·»åŠ äº¤æ¢æŒ‰é’®
                if (h.hasSwapBtn && currentTab !== 'all') {
                    const swapBtn = document.createElement('button');
                    swapBtn.innerHTML = 'ğŸ”„';
                    swapBtn.className = 'header-btn swap-time-btn';
                    swapBtn.style.cssText = 'margin-left: 6px; padding: 2px 6px; font-size: 0.9em; cursor: pointer; background: transparent; border: 1px solid #555; border-radius: 4px;';
                    swapBtn.title = 'äº¤æ¢é€‰ä¸­ä¸¤ä¸ªèˆªç­çš„æ—¶é—´';
                    swapBtn.onclick = () => swapSelectedFlightTimes(h.key);
                    container.appendChild(swapBtn);
                }

                th.appendChild(container);
                th.style.width = h.width || 'auto';
                tr.appendChild(th);
            });
            const thAction = document.createElement('th');
            thAction.style.width = '40px';
            thAction.innerText = 'æ“ä½œ';
            tr.appendChild(thAction);
        }

        // éšæœºæ’åˆ—å½“å‰è§†å›¾çš„èˆªç­
        async function shuffleFlights() {
            if (currentTab === 'all') {
                await showAlertModal('è¯·å…ˆåˆ‡æ¢åˆ°ã€Œåˆ°è¾¾èˆªç­ã€æˆ–ã€Œå‡ºå‘èˆªç­ã€æ ‡ç­¾é¡µ', 'warning');
                return;
            }

            // è·å–å½“å‰è§†å›¾çš„èˆªç­ç´¢å¼•
            const filtered = getFilteredFlights();
            if (filtered.length < 2) return;

            // Fisher-Yates æ´—ç‰Œç®—æ³•
            const indices = filtered.map(item => item.index);
            const flights = indices.map(idx => allFlights[idx]);

            for (let i = flights.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [flights[i], flights[j]] = [flights[j], flights[i]];
            }

            // å°†æ´—ç‰Œåçš„èˆªç­å†™å›åŸä½ç½®
            indices.forEach((originalIdx, newIdx) => {
                allFlights[originalIdx] = flights[newIdx];
            });

            renderTable();
            showStatus(`å·²éšæœºæ’åˆ— ${flights.length} æ¡èˆªç­`);
        }

        // äº¤æ¢é€‰ä¸­ä¸¤ä¸ªèˆªç­çš„æ—¶é—´
        function swapSelectedFlightTimes(key) {
            if (selectedIndices.size !== 2) {
                showAlertModal('ä»…é€‰ä¸­2ä¸ªèˆªç­æ‰èƒ½äº¤æ¢', 'warning');
                return;
            }
            const [idx1, idx2] = [...selectedIndices];
            const temp = allFlights[idx1][key];
            allFlights[idx1][key] = allFlights[idx2][key];
            allFlights[idx2][key] = temp;

            // ç«‹å³æ›´æ–°è¡ç”Ÿæ—¶é—´å­—æ®µ
            triggerAutoCalc(idx1, key, allFlights[idx1][key]);
            triggerAutoCalc(idx2, key, allFlights[idx2][key]);

            // æŒ‰æ—¶é—´å‡åºæ’åˆ—å½“å‰è§†å›¾çš„èˆªç­
            const filtered = getFilteredFlights();
            const indices = filtered.map(item => item.index);
            const flights = indices.map(idx => allFlights[idx]);

            // æ ¹æ®å½“å‰ tab å†³å®šæ’åºå­—æ®µ
            const sortKey = currentTab === 'departure' ? 'offBlockTime' : 'landingTime';
            flights.sort((a, b) => (a[sortKey] || '').localeCompare(b[sortKey] || ''));

            // å†™å›åŸä½ç½®
            indices.forEach((originalIdx, newIdx) => {
                allFlights[originalIdx] = flights[newIdx];
            });

            selectedIndices.clear(); // æ¸…é™¤é€‰æ‹©ä»¥é¿å…ç´¢å¼•æ··ä¹±
            renderTable();
            const labelMap = { offBlockTime: 'æ¨å‡ºæ—¶é—´', landingTime: 'ç€é™†æ—¶é—´' };
            showStatus(`å·²äº¤æ¢æ—¶é—´å¹¶æŒ‰${labelMap[sortKey]}å‡åºæ’åˆ—`);
        }

        // æ¸…ç©ºå½“å‰è§†å›¾èˆªç­çš„åœæœºä½
        async function clearStands() {
            const filtered = getFilteredFlights();
            if (filtered.length === 0) {
                await showAlertModal('å½“å‰è§†å›¾æ²¡æœ‰èˆªç­æ•°æ®', 'warning');
                return;
            }

            const confirmed = await showConfirmModal(`ç¡®å®šè¦æ¸…ç©ºå½“å‰è§†å›¾ ${filtered.length} æ¡èˆªç­çš„åœæœºä½å—ï¼Ÿ`);
            if (!confirmed) return;

            filtered.forEach(item => {
                allFlights[item.index].stand = '';
            });

            renderTable();
            showStatus(`å·²æ¸…ç©º ${filtered.length} æ¡èˆªç­çš„åœæœºä½`);
        }

        // è‡ªå®šä¹‰ç¡®è®¤å¯¹è¯æ¡†
        function showConfirmModal(message) {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmModal');
                const msgEl = document.getElementById('confirmMessage');
                const btnOk = document.getElementById('btnConfirmOk');
                const btnCancel = document.getElementById('btnConfirmCancel');

                msgEl.textContent = message;
                modal.style.display = 'flex';

                const cleanup = () => {
                    modal.style.display = 'none';
                    btnOk.onclick = null;
                    btnCancel.onclick = null;
                };

                btnOk.onclick = () => {
                    cleanup();
                    resolve(true);
                };

                btnCancel.onclick = () => {
                    cleanup();
                    resolve(false);
                };
            });
        }

        // è‡ªå®šä¹‰æç¤ºå¯¹è¯æ¡†
        function showAlertModal(message, type = 'info') {
            return new Promise((resolve) => {
                const modal = document.getElementById('alertModal');
                const titleEl = document.getElementById('alertTitle');
                const msgEl = document.getElementById('alertMessage');
                const btnOk = document.getElementById('btnAlertOk');

                // è®¾ç½®å›¾æ ‡å’Œæ ‡é¢˜
                const titles = {
                    info: 'â„¹ï¸ æç¤º',
                    success: 'âœ… æˆåŠŸ',
                    warning: 'âš ï¸ è­¦å‘Š'
                };
                titleEl.textContent = titles[type] || titles.info;

                msgEl.textContent = message;
                modal.style.display = 'flex';

                btnOk.onclick = () => {
                    modal.style.display = 'none';
                    btnOk.onclick = null;
                    resolve();
                };
            });
        }

        function renderTable() {
            if (currentTab === 'standView') {
                renderStandView();
                return;
            }

            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            const callsignCounts = {};
            allFlights.forEach(f => {
                if (f.callSign) callsignCounts[f.callSign] = (callsignCounts[f.callSign] || 0) + 1;
            });

            // æ£€æµ‹åœæœºä½å†²çª
            const standConflicts = detectStandConflicts();
            const conflictIndices = new Set();
            standConflicts.forEach((indices, stand) => {
                indices.forEach(idx => conflictIndices.add(idx));
            });

            // æ£€æµ‹å…ˆå‡ºåè¿›åœæœºä½
            const turnaroundStats = getStandUsageStats();
            const turnaroundStands = turnaroundStats.turnarounds;

            const filteredFlights = getFilteredFlights();

            filteredFlights.forEach((item, visualIndex) => {
                const tr = document.createElement('tr');
                const f = item.flight;
                const idx = item.index;
                tr.dataset.index = idx;
                tr.onmousedown = (e) => handleRowSelection(e, idx, visualIndex);
                tr.oncontextmenu = (e) => { if (e.shiftKey) e.preventDefault(); };

                if (selectedIndices.has(idx)) tr.classList.add('selected-row');

                // é‡å¤å‘¼å·é«˜äº®
                const isDuplicate = f.callSign && callsignCounts[f.callSign] > 1;
                if (isDuplicate) {
                    tr.classList.add('duplicate-row');
                    tr.dataset.callsign = f.callSign;
                    tr.addEventListener('mouseenter', () => highlightDuplicates(f.callSign));
                    tr.addEventListener('mouseleave', () => unhighlightDuplicates(f.callSign));
                }

                // åœæœºä½å†²çªé«˜äº®
                const hasConflict = conflictIndices.has(idx);
                if (hasConflict) {
                    tr.classList.add('conflict-row');
                    // æ‰¾åˆ°å†²çªçš„åœæœºä½
                    standConflicts.forEach((indices, stand) => {
                        if (indices.has(idx)) {
                            tr.dataset.conflictStand = stand;
                        }
                    });
                    tr.addEventListener('mouseenter', () => highlightConflicts(tr.dataset.conflictStand));
                    tr.addEventListener('mouseleave', () => unhighlightConflicts(tr.dataset.conflictStand));
                }

                // å…ˆå‡ºåè¿›åœæœºä½æ°¸ä¹…é«˜äº®ï¼ˆä»…å½“ä¸å­˜åœ¨å†²çªæ—¶ï¼‰
                if (f.stand && turnaroundStands.has(f.stand) && !hasConflict) {
                    tr.classList.add('turnaround-row');
                    tr.dataset.turnaroundStand = f.stand;
                    tr.addEventListener('mouseenter', () => highlightTurnaround(f.stand));
                    tr.addEventListener('mouseleave', () => unhighlightTurnaround(f.stand));
                }

                headers.forEach(h => {
                    if (currentTab === 'all') {
                        if (h.key === 'takeOffTime' || h.key === 'inBlockTime') return;
                    } else {
                        if (h.tab && h.tab !== currentTab) return;
                    }
                    const td = document.createElement('td');
                    if (h.type === 'select') {
                        const select = document.createElement('select');
                        let options = config[h.source];
                        if (h.key === 'airline') {
                            const acType = f.aircraftType;
                            if (acType && config.mapping.aircraftToAirlines[acType]) {
                                const allowedAirlines = config.mapping.aircraftToAirlines[acType];
                                options = options.filter(al => allowedAirlines.includes(al));
                            }
                        }
                        else if (h.key === 'aircraftType') {
                            const al = f.airline;
                            if (al && config.mapping.airlineToAircrafts[al]) {
                                const allowedTypes = config.mapping.airlineToAircrafts[al];
                                options = options.filter(at => allowedTypes.includes(at));
                            }
                        }
                        else if (h.key === 'callSign') {
                            const al = f.airline;
                            if (al && config.mapping.airlineToCallsigns[al]) {
                                options = config.mapping.airlineToCallsigns[al];
                            }
                        }
                        else if (h.key === 'stand') {
                            // åœæœºä½ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœæœªé…ç½®ä¸”æœ‰ç°æœ‰å€¼ï¼Œä¿ç•™ç°æœ‰å€¼ä½œä¸ºé€‰é¡¹
                            if (options.length === 0 && f[h.key]) {
                                options = [f[h.key]];
                            }
                            // å§‹ç»ˆæ·»åŠ ç©ºé€‰é¡¹ï¼Œå…è®¸æ¸…é™¤å·²åˆ†é…çš„åœæœºä½
                            if (options.length > 0) {
                                const emptyOpt = document.createElement('option');
                                emptyOpt.value = '';
                                emptyOpt.text = '-- æœªåˆ†é… --';
                                emptyOpt.selected = !f[h.key];
                                select.appendChild(emptyOpt);
                            }
                        }
                        if (f[h.key] && !options.includes(f[h.key])) {
                            const opt = document.createElement('option');
                            opt.value = f[h.key];
                            opt.text = f[h.key] + " (éé…ç½®)";
                            select.appendChild(opt);
                        }
                        options.forEach(optVal => {
                            const opt = document.createElement('option');
                            opt.value = optVal;
                            opt.text = optVal;
                            if (optVal === f[h.key]) opt.selected = true;
                            select.appendChild(opt);
                        });
                        select.onchange = (e) => {
                            const newVal = e.target.value;
                            updateFlight(idx, h.key, newVal);
                            if (h.key === 'callSign') {
                                const mappedAirline = config.mapping.callsignToAirline[newVal];
                                if (mappedAirline) updateFlight(idx, 'airline', mappedAirline);
                            }
                            renderTable();
                        };

                        // è‡ªåŠ¨åŒæ­¥ï¼šå¦‚æœèˆªç­æ²¡æœ‰è¯¥å­—æ®µå€¼ï¼Œä½†ä¸‹æ‹‰æ¡†æœ‰é€‰é¡¹ï¼Œåˆ™ä¿å­˜å½“å‰æ˜¾ç¤ºçš„å€¼
                        // æ’é™¤åœæœºä½å­—æ®µï¼ˆéœ€è¦ç”¨æˆ·ä¸»åŠ¨é€‰æ‹©ï¼‰
                        if (h.key !== 'stand' && !f[h.key] && select.options.length > 0) {
                            const currentValue = select.value;
                            if (currentValue) {
                                allFlights[idx][h.key] = currentValue;
                            }
                        }

                        td.appendChild(select);
                    } else {
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.value = f[h.key] || '';
                        input.dataset.row = idx;
                        input.dataset.key = h.key;
                        if (isAirportLocked) {
                            if ((h.key === 'departure' || h.key === 'arrival') && f[h.key] === currentAirportCode) {
                                input.readOnly = true;
                                input.className = 'locked';
                            }
                        }
                        if (h.type === 'time') {
                            input.placeholder = "HH:mm:ss";
                            input.onfocus = (e) => { e.target.setAttribute('data-original', e.target.value); };
                            input.onblur = (e) => {
                                const orig = e.target.getAttribute('data-original');
                                handleTimeBlur(e, orig, idx, h.key);
                            };
                            input.onkeydown = (e) => handleTimeKeyDown(e, input, idx, h.key);
                        } else {
                            input.onchange = (e) => updateFlight(idx, h.key, e.target.value);
                        }
                        td.appendChild(input);
                    }
                    tr.appendChild(td);
                });
                const tdAction = document.createElement('td');
                tdAction.className = 'cell-action';
                tdAction.innerHTML = `<button class="btn-delete" onclick="deleteFlightRecord(${idx})">ğŸ—‘ï¸</button>`;
                tr.appendChild(tdAction);
                tbody.appendChild(tr);
            });
        }

        function updateFlight(index, key, value) {
            allFlights[index][key] = value;
        }

        function updateFlightAircraft(dataIndex, newType) {
            // ç±»å‹è½¬æ¢é˜²æ­¢å­—ç¬¦ä¸²ç´¢å¼•é—®é¢˜
            const idx = parseInt(dataIndex);
            if (allFlights[idx]) {
                allFlights[idx].aircraftType = newType;
                // æ•°æ®æ›´æ–°åç«‹å³åˆ·æ–°è§†å›¾
                renderTable();
                updateStats();
                // console.log(`Flight ${idx} updated to ${newType}`);
            }
        }

        function addRow() {
            let defDeparture = 'ZBAA';
            let defArrival = 'ZSJN';
            let isDepartureIntent = true;
            if (currentTab === 'arrival') isDepartureIntent = false;
            else if (currentTab === 'all') isDepartureIntent = true;

            if (isAirportLocked && currentAirportCode) {
                if (!isDepartureIntent) defArrival = currentAirportCode;
                else defDeparture = currentAirportCode;
            } else {
                if (!isDepartureIntent) { defArrival = 'ZSJN'; defDeparture = 'ZBAA'; }
                else { defDeparture = 'ZSJN'; defArrival = 'ZBAA'; }
            }

            const defAirline = config.airlines[0] || 'CSN';
            let defAircraft = config.aircraftTypes[0] || 'BOEING 737-800';
            if (config.mapping.airlineToAircrafts[defAirline] && config.mapping.airlineToAircrafts[defAirline].length > 0) {
                defAircraft = config.mapping.airlineToAircrafts[defAirline][0];
            }

            let defCallsign = '';
            if (config.mapping.airlineToCallsigns[defAirline] && config.mapping.airlineToCallsigns[defAirline].length > 0) {
                defCallsign = config.mapping.airlineToCallsigns[defAirline][0];
            } else if (config.callsigns.length > 0) {
                defCallsign = config.callsigns[0];
            }

            const newFlight = {
                callSign: defCallsign || 'NEW001',
                departure: defDeparture,
                arrival: defArrival,
                stand: '1',
                runway: '01',
                airline: defAirline,
                aircraftType: defAircraft,
                voice: config.voices[0] || 'CN-Captain-Young',
                language: 'zh'
            };

            if (isDepartureIntent) {
                newFlight.offBlockTime = '08:00:00';
                if (timeOffsets.departure) {
                    newFlight.takeOffTime = addMinutes('08:00:00', timeOffsets.departure);
                } else {
                    newFlight.takeOffTime = '08:10:00';
                }
                newFlight.landingTime = '';
                newFlight.inBlockTime = '';
            } else {
                newFlight.offBlockTime = '';
                newFlight.takeOffTime = '';
                newFlight.landingTime = '08:00:00';
                if (timeOffsets.arrival) {
                    newFlight.inBlockTime = addMinutes('08:00:00', timeOffsets.arrival);
                } else {
                    newFlight.inBlockTime = '08:10:00';
                }
            }

            allFlights.push(newFlight);
            renderTable();
            updateStats();
            const container = document.querySelector('.table-container');
            container.scrollTop = container.scrollHeight;
        }

        async function deleteFlightRecord(index) {
            if (await showConfirmModal("ç¡®å®šåˆ é™¤è¯¥èˆªç­å—?")) {
                allFlights.splice(index, 1);
                selectedIndices.delete(index);
                selectedIndices.clear();
                renderTable();
                updateStats();
            }
        }
        async function newFile() {
            if (await showConfirmModal("ç¡®å®šæ–°å»ºå—? æœªä¿å­˜çš„æ•°æ®å°†ä¸¢å¤±ã€‚")) {
                allFlights = [];
                selectedIndices.clear();
                const csvInput = document.getElementById('csvInput');
                if (csvInput) csvInput.value = '';
                renderTable();
                updateStats();
                showStatus("å·²æ–°å»ºç©ºè¡¨");
            }
        }
        function loadCSV(input) {
            const file = input.files[0];
            if (!file) return;

            // è‡ªåŠ¨è®¾ç½®å¯¼å‡ºæ–‡ä»¶åï¼ˆå»æ‰ .csv æ‰©å±•åï¼‰
            const baseName = file.name.replace(/\.csv$/i, '');
            document.getElementById('exportFilename').value = baseName;

            const reader = new FileReader();
            reader.onload = function (e) {
                const text = e.target.result;
                parseCSV(text);
                input.value = '';
            };
            reader.readAsText(file);
        }
        function parseCSV(text) {
            const lines = text.split(/\r\n|\n/).filter(l => l.trim() !== '' && !l.trim().startsWith('#'));
            if (lines.length < 2) { alert("CSV æ ¼å¼é”™è¯¯æˆ–ä¸ºç©º"); return; }
            const normalizeKey = (k) => {
                k = k.trim();
                if (k === 'offBlockTIme') return 'offBlockTime';
                if (k === 'inBlockTIme') return 'inBlockTime';
                if (k === 'takeOffTIme') return 'takeOffTime';
                return k;
            };
            const headerLine = lines[0].split(',').map(normalizeKey);
            const newFlights = [];
            for (let i = 1; i < lines.length; i++) {
                const cols = lines[i].split(',').map(c => c.trim());
                if (cols.length < headerLine.length) continue;
                let flight = {};
                headerLine.forEach((h, idx) => { flight[h] = cols[idx]; });
                newFlights.push(flight);
            }
            allFlights = [...allFlights, ...newFlights]; // å¢é‡å¯¼å…¥ï¼ˆè¿½åŠ æ¨¡å¼ï¼‰
            selectedIndices.clear();
            renderTable();
            updateStats();

            // è‡ªåŠ¨æ£€æµ‹å¹¶é”å®šå½“å‰æœºåœº
            const detectedAirport = detectCurrentAirport();
            if (detectedAirport && !isAirportLocked) {
                const input = document.getElementById('airportCode');
                const btn = document.getElementById('btnLock');
                currentAirportCode = detectedAirport;
                isAirportLocked = true;
                input.value = detectedAirport;
                input.disabled = true;
                btn.innerHTML = "ğŸ”’ è§£é”";
                btn.classList.add("active-lock");
                updateBatchButtons();
                showStatus(`å·²åŠ è½½ ${allFlights.length} æ¡èˆªç­æ•°æ®ï¼Œè‡ªåŠ¨æ£€æµ‹å¹¶é”å®šæœºåœº: ${detectedAirport}`);
            } else {
                showStatus(`å·²åŠ è½½ ${allFlights.length} æ¡èˆªç­æ•°æ®`);
            }

            // è‡ªåŠ¨æ£€æµ‹å¹¶æ›´æ–°åœæœºä½æ•°é‡
            autoDetectStandCount(newFlights);
        }

        // è‡ªåŠ¨æ£€æµ‹åœæœºä½æ•°é‡ï¼šæå– stand åˆ—æœ€å¤§å€¼å¹¶æ›´æ–°é…ç½®
        function autoDetectStandCount(flights) {
            if (!flights || flights.length === 0) return;

            // æå–æ‰€æœ‰ stand å€¼å¹¶æ‰¾å‡ºæœ€å¤§æ•°å€¼
            let maxStand = 0;
            flights.forEach(f => {
                if (f.stand) {
                    const standNum = parseInt(f.stand);
                    if (!isNaN(standNum) && standNum > maxStand) {
                        maxStand = standNum;
                    }
                }
            });

            if (maxStand === 0) return; // æ²¡æœ‰æœ‰æ•ˆçš„åœæœºä½æ•°æ®

            const currentCount = config.stands.length;

            // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡ï¼ˆå½“å‰æ— åœæœºä½é…ç½®ï¼‰æˆ–æ–°æ•°æ®çš„æœ€å¤§å€¼æ›´å¤§ï¼Œåˆ™æ›´æ–°
            if (currentCount === 0 || maxStand > currentCount) {
                config.stands = [];
                for (let i = 1; i <= maxStand; i++) {
                    config.stands.push(i.toString());
                }

                const action = currentCount === 0 ? 'è‡ªåŠ¨æ£€æµ‹' : 'è‡ªåŠ¨æ‰©å±•';
                showStatus(`${action}åœæœºä½æ•°é‡: ${maxStand} ä¸ª`);
            }
        }

        // è‡ªåŠ¨æ£€æµ‹å½“å‰æœºåœºï¼šç»Ÿè®¡å‡ºç°æ¬¡æ•°ç­‰äºèˆªç­æ€»æ•°çš„æœºåœºä»£ç 
        function detectCurrentAirport() {
            if (allFlights.length === 0) return null;

            const count = {};
            allFlights.forEach(f => {
                if (f.departure) count[f.departure] = (count[f.departure] || 0) + 1;
                if (f.arrival) count[f.arrival] = (count[f.arrival] || 0) + 1;
            });

            const total = allFlights.length;
            for (const code in count) {
                if (count[code] === total) return code;
            }
            return null;
        }
        function loadConfigs(input) {
            const files = Array.from(input.files);
            let loadedCount = 0;
            config.mapping.aircraftToAirlines = {};
            config.mapping.airlineToAircrafts = {};
            files.forEach(file => {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const text = e.target.result;
                    if (file.name.includes("ModelPath")) parseModelConfig(text);
                    else if (file.name.includes("LiveryPath")) parseLiveryConfig(text);
                    loadedCount++;
                    if (loadedCount === files.length) {
                        showStatus("é…ç½®åŠ è½½å®Œæˆ");
                        buildReverseMapping();
                        renderTable();
                    }
                };
                reader.readAsText(file);
            });
            input.value = '';
        }

        function loadCallsigns(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function (e) {
                const text = e.target.result;
                parseCallsignConfig(text);
                showStatus("å‘¼å·è¡¨å·²æ›´æ–°");
                renderTable();
                input.value = '';
            };
            reader.readAsText(file);
        }

        function parseCallsignConfig(text) {
            const lines = text.split(/\r\n|\n/);
            const callsigns = [];
            config.mapping.callsignToAirline = {};
            config.mapping.airlineToCallsigns = {};

            config.airlines.forEach(al => config.mapping.airlineToCallsigns[al] = []);

            lines.forEach(line => {
                line = line.trim();
                if (!line || line.startsWith('callSign')) return;
                const parts = line.split(',');
                if (parts.length >= 2) {
                    const cs = parts[0].trim();
                    const al = parts[1].trim();
                    if (cs && al) {
                        callsigns.push(cs);
                        config.mapping.callsignToAirline[cs] = al;
                        if (!config.mapping.airlineToCallsigns[al]) {
                            config.mapping.airlineToCallsigns[al] = [];
                        }
                        config.mapping.airlineToCallsigns[al].push(cs);
                    }
                }
            });
            config.callsigns = callsigns.sort();
            console.log("Loaded Callsigns:", callsigns.length);
        }

        function parseModelConfig(text) {
            const types = [];
            const lines = text.split(/\r\n|\n/);
            lines.forEach(line => {
                const parts = line.split('=');
                if (parts.length >= 2) {
                    const key = parts[0].trim();
                    if (key) types.push(key);
                }
            });
            if (types.length > 0) {
                config.aircraftTypes = types;
            }
        }
        function parseLiveryConfig(text) {
            const airlines = new Set();
            const lines = text.split(/\r\n|\n/);
            let currentAircraft = null;
            lines.forEach(line => {
                line = line.trim();
                if (!line) return;
                if (line.includes('=')) {
                    const parts = line.split('=');
                    const key = parts[0].trim();
                    if (key && key.length === 3) {
                        airlines.add(key);
                        if (currentAircraft) {
                            // æ­£å‘æ˜ å°„ï¼šæœºå‹ -> èˆªç©ºå…¬å¸åˆ—è¡¨
                            if (!config.mapping.aircraftToAirlines[currentAircraft]) config.mapping.aircraftToAirlines[currentAircraft] = [];
                            if (!config.mapping.aircraftToAirlines[currentAircraft].includes(key)) config.mapping.aircraftToAirlines[currentAircraft].push(key);
                            // åå‘æ˜ å°„ï¼šèˆªç©ºå…¬å¸ -> æœºå‹åˆ—è¡¨
                            if (!config.mapping.airlineToAircrafts[key]) config.mapping.airlineToAircrafts[key] = [];
                            if (!config.mapping.airlineToAircrafts[key].includes(currentAircraft)) config.mapping.airlineToAircrafts[key].push(currentAircraft);
                        }
                    }
                } else {
                    if (!line.startsWith('[') && !line.startsWith('/')) {
                        currentAircraft = line;
                        if (!config.mapping.aircraftToAirlines[currentAircraft]) config.mapping.aircraftToAirlines[currentAircraft] = [];
                    }
                }
            });
            if (airlines.size > 0) {
                config.airlines = Array.from(airlines).sort();
            }
        }
        async function downloadCSV() {
            const arrivals = allFlights.filter(f => !f.offBlockTime && f.landingTime);
            const departures = allFlights.filter(f => !(!f.offBlockTime && f.landingTime));
            arrivals.sort((a, b) => (a.landingTime || '').localeCompare(b.landingTime || ''));
            departures.sort((a, b) => (a.offBlockTime || '').localeCompare(b.offBlockTime || ''));
            const sortedFlights = [...arrivals, ...departures];
            const headerKeys = headers.filter(h => h.key).map(h => h.key);
            let csvContent = headerKeys.join(',') + "\n";
            sortedFlights.forEach(f => {
                const row = headerKeys.map(key => f[key] || '').join(',');
                csvContent += row + "\n";
            });

            // è·å–ç”¨æˆ·è¾“å…¥çš„æ–‡ä»¶å
            let filename = document.getElementById('exportFilename').value.trim();
            if (!filename) filename = 'flight_schedule';
            filename = filename.replace(/\.csv$/i, '') + '.csv';

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });

            // å°è¯•ä½¿ç”¨ File System Access APIï¼ˆé€‰æ‹©ç›®å½•åç›´æ¥å¯¼å‡ºï¼‰
            if ('showDirectoryPicker' in window) {
                try {
                    const dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
                    const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    showStatus(`å·²å¯¼å‡º: ${filename} â†’ ${dirHandle.name}/`);
                    return;
                } catch (err) {
                    if (err.name === 'AbortError') return; // ç”¨æˆ·å–æ¶ˆ
                    console.warn('ç›®å½•å¯¼å‡ºå¤±è´¥ï¼Œå›é€€åˆ°ä¼ ç»Ÿä¸‹è½½:', err);
                }
            }

            // å›é€€ï¼šä¼ ç»Ÿä¸‹è½½æ–¹å¼
            const link = document.createElement("a");
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                showStatus(`å·²ä¸‹è½½: ${filename}`);
            }
        }

        // === è‡ªåŠ¨é…è¡¨åŠŸèƒ½ ===
        async function openAutoScheduleModal() {
            // æ£€æŸ¥æ˜¯å¦æœ‰é€‰ä¸­èˆªç­
            if (selectedIndices.size === 0) {
                await showAlertModal('è¯·å…ˆé€‰ä¸­è¦é…ç½®çš„èˆªç­', 'warning');
                return;
            }

            // ç¦æ­¢åœ¨"å…¨éƒ¨"æ ‡ç­¾é¡µä½¿ç”¨ï¼ˆå› ä¸ºæ— æ³•åŒºåˆ†åˆ°è¾¾/å‡ºå‘ï¼‰
            if (currentTab === 'all') {
                await showAlertModal('è¯·å…ˆåˆ‡æ¢åˆ°ã€Œåˆ°è¾¾èˆªç­ã€æˆ–ã€Œå‡ºå‘èˆªç­ã€æ ‡ç­¾é¡µ', 'warning');
                return;
            }

            // æ›´æ–°é¢„è§ˆä¿¡æ¯
            updateAutoSchedulePreview();

            // æ˜¾ç¤ºæ¨¡æ€æ¡†
            document.getElementById('autoScheduleModal').style.display = 'flex';
        }

        function closeAutoScheduleModal() {
            document.getElementById('autoScheduleModal').style.display = 'none';
        }

        function updateAutoSchedulePreview() {
            const selectedCount = selectedIndices.size;
            const startTime = document.getElementById('autoStartTime').value;
            const interval = parseInt(document.getElementById('autoInterval').value) || 5;

            const tabLabel = currentTab === 'arrival' ? 'åˆ°è¾¾èˆªç­' : 'å‡ºå‘èˆªç­';
            const timeField = currentTab === 'arrival' ? 'ç€é™†æ—¶é—´' : 'æ¨å‡ºæ—¶é—´';
            const lastTime = selectedCount > 0 ? addMinutes(startTime, interval * (selectedCount - 1)) : startTime;

            const previewEl = document.getElementById('autoSchedulePreview');
            previewEl.innerHTML = `
                <div><strong>å½“å‰è§†å›¾:</strong> ${tabLabel}</div>
                <div><strong>é€‰ä¸­èˆªç­:</strong> ${selectedCount} æ¡</div>
                <div><strong>è®¾ç½®å­—æ®µ:</strong> ${timeField}</div>
                <div><strong>æ—¶é—´èŒƒå›´:</strong> ${startTime} â†’ ${lastTime}</div>
            `;
        }

        async function applyAutoSchedule() {
            const startTimeStr = document.getElementById('autoStartTime').value.trim();
            const interval = parseInt(document.getElementById('autoInterval').value);

            // éªŒè¯è¾“å…¥
            if (!isValidTimeFormat(startTimeStr)) {
                await showAlertModal('è¯·è¾“å…¥æ­£ç¡®çš„æ—¶é—´æ ¼å¼ (HH:mm:ss)', 'warning');
                return;
            }
            if (isNaN(interval) || interval < 1) {
                await showAlertModal('é—´éš”æ—¶é—´å¿…é¡»ä¸ºæ­£æ•´æ•°', 'warning');
                return;
            }

            // è·å–é€‰ä¸­èˆªç­çš„ç´¢å¼•å¹¶æ’åº
            const selectedFlightIndices = [...selectedIndices].sort((a, b) => a - b);
            const offset = timeOffsets[currentTab] || 10;

            // ç¡®å®šè¦è®¾ç½®çš„å­—æ®µ
            const primaryKey = currentTab === 'arrival' ? 'landingTime' : 'offBlockTime';
            const secondaryKey = currentTab === 'arrival' ? 'inBlockTime' : 'takeOffTime';

            // æŒ‰é¡ºåºè®¾ç½®æ—¶é—´
            selectedFlightIndices.forEach((index, i) => {
                const flight = allFlights[index];
                const calculatedTime = addMinutes(startTimeStr, interval * i);

                flight[primaryKey] = calculatedTime;
                flight[secondaryKey] = addMinutes(calculatedTime, offset);
            });

            // å…³é—­å¯¹è¯æ¡†å¹¶åˆ·æ–°
            closeAutoScheduleModal();
            renderTable();
            updateStats();
            showStatus(`å·²ä¸º ${selectedFlightIndices.length} æ¡é€‰ä¸­èˆªç­è‡ªåŠ¨é…ç½®æ—¶é—´`);
        }

        // ä»…åº”ç”¨æ—¶é—´åç§»
        async function applyTimeOffset() {
            const offsetMinutes = parseInt(document.getElementById('autoTimeOffset').value);

            if (isNaN(offsetMinutes) || offsetMinutes === 0) {
                await showAlertModal('è¯·è¾“å…¥æœ‰æ•ˆçš„åç§»åˆ†é’Ÿæ•°ï¼ˆéé›¶æ•´æ•°ï¼‰', 'warning');
                return;
            }

            const filtered = getFilteredFlights();
            if (filtered.length === 0) {
                await showAlertModal('å½“å‰è§†å›¾æ²¡æœ‰èˆªç­æ•°æ®', 'warning');
                return;
            }

            // ç¡®å®šè¦åç§»çš„å­—æ®µ
            const primaryKey = currentTab === 'arrival' ? 'landingTime' : 'offBlockTime';
            const secondaryKey = currentTab === 'arrival' ? 'inBlockTime' : 'takeOffTime';

            let modifiedCount = 0;
            filtered.forEach(item => {
                const flight = allFlights[item.index];

                // åç§»ä¸»æ—¶é—´å­—æ®µ
                if (flight[primaryKey] && isValidTimeFormat(flight[primaryKey])) {
                    flight[primaryKey] = addMinutes(flight[primaryKey], offsetMinutes);
                    modifiedCount++;
                }

                // åç§»æ¬¡æ—¶é—´å­—æ®µ
                if (flight[secondaryKey] && isValidTimeFormat(flight[secondaryKey])) {
                    flight[secondaryKey] = addMinutes(flight[secondaryKey], offsetMinutes);
                }
            });

            closeAutoScheduleModal();
            renderTable();
            updateStats();

            const direction = offsetMinutes > 0 ? 'å»¶å' : 'æå‰';
            showStatus(`å·²å°† ${modifiedCount} æ¡èˆªç­æ—¶é—´${direction} ${Math.abs(offsetMinutes)} åˆ†é’Ÿ`);
        }

        // === æœºåœºä¿¡æ¯åŠŸèƒ½ ===
        function openAirportInfoModal() {
            // å¦‚æœå·²æœ‰åœæœºä½é…ç½®ï¼Œæ˜¾ç¤ºå½“å‰æ•°é‡
            const currentCount = config.stands.length;
            if (currentCount > 0) {
                document.getElementById('standCount').value = currentCount;
            }
            updateAirportInfoPreview();
            document.getElementById('airportInfoModal').style.display = 'flex';
        }

        function closeAirportInfoModal() {
            document.getElementById('airportInfoModal').style.display = 'none';
        }

        // åœæœºä½ä½¿ç”¨çŠ¶å†µç»Ÿè®¡ï¼ˆå«æ—¶é—´æ ¡éªŒï¼‰
        // åˆæ³•è“è‰²é«˜äº®æ¡ä»¶ï¼š
        // 1. å¤šå‡ºå‘ï¼ˆæ— åˆ°è¾¾ï¼‰- åˆæ³•
        // 2. 1åˆ°è¾¾+1å‡ºå‘ï¼Œä¸”å‡ºå‘æ—¶é—´ < åˆ°è¾¾æ—¶é—´ï¼ˆå…ˆå‡ºåè¿›ï¼‰- åˆæ³•
        function getStandUsageStats() {
            const arrivals = new Set();   // æœ‰åˆ°è¾¾èˆªç­çš„åœæœºä½
            const departures = new Set(); // æœ‰å‡ºå‘èˆªç­çš„åœæœºä½
            const standFlights = new Map(); // ç”¨äºæ—¶é—´æ ¡éªŒ

            allFlights.forEach(f => {
                if (!f.stand) return;
                const type = getFlightType(f);
                if (type === 'arrival') arrivals.add(f.stand);
                if (type === 'departure') departures.add(f.stand);

                // æ”¶é›†æ¯ä¸ªåœæœºä½çš„èˆªç­ç”¨äºæ—¶é—´æ ¡éªŒ
                if (!standFlights.has(f.stand)) {
                    standFlights.set(f.stand, { arrivalFlights: [], departureFlights: [] });
                }
                if (type === 'arrival') {
                    standFlights.get(f.stand).arrivalFlights.push(f);
                } else {
                    standFlights.get(f.stand).departureFlights.push(f);
                }
            });

            // æ£€æµ‹åˆæ³•çš„è“è‰²é«˜äº®åœæœºä½
            const turnarounds = new Set();
            standFlights.forEach((data, stand) => {
                const arrCount = data.arrivalFlights.length;
                const depCount = data.departureFlights.length;

                // åœºæ™¯1: å¤šå‡ºå‘ï¼ˆæ— åˆ°è¾¾ï¼Œä¸”â‰¥2ä¸ªå‡ºå‘ï¼‰- åˆæ³•ï¼Œè“è‰²
                if (arrCount === 0 && depCount >= 2) {
                    turnarounds.add(stand);
                }
                // åœºæ™¯2: 1åˆ°è¾¾+1å‡ºå‘ï¼Œä¸”å…ˆå‡ºåè¿› - åˆæ³•ï¼Œè“è‰²
                else if (arrCount === 1 && depCount === 1) {
                    const arr = data.arrivalFlights[0];
                    const dep = data.departureFlights[0];
                    const arrTime = arr.inBlockTime || arr.landingTime;
                    const depTime = dep.takeOffTime || dep.offBlockTime;

                    // å…ˆå‡ºåè¿›ï¼šå‡ºå‘æ—¶é—´ < åˆ°è¾¾æ—¶é—´
                    if (arrTime && depTime && compareTime(depTime, arrTime) < 0) {
                        turnarounds.add(stand);
                    }
                }
                // åœºæ™¯3: 1åˆ°è¾¾+å¤šå‡ºå‘ï¼Œéœ€è¦æ£€æŸ¥æ‰€æœ‰å‡ºå‘éƒ½åœ¨åˆ°è¾¾ä¹‹å‰
                else if (arrCount === 1 && depCount > 1) {
                    const arr = data.arrivalFlights[0];
                    const arrTime = arr.inBlockTime || arr.landingTime;

                    // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å‡ºå‘éƒ½åœ¨åˆ°è¾¾ä¹‹å‰å®Œæˆ
                    const allDeparturesBeforeArrival = data.departureFlights.every(dep => {
                        const depTime = dep.takeOffTime || dep.offBlockTime;
                        return arrTime && depTime && compareTime(depTime, arrTime) < 0;
                    });

                    if (allDeparturesBeforeArrival) {
                        turnarounds.add(stand);
                    }
                }
            });

            return { arrivals, departures, turnarounds };
        }

        function updateAirportInfoPreview() {
            const countInput = document.getElementById('standCount').value;
            const count = parseInt(countInput) || 0;
            const previewEl = document.getElementById('airportInfoPreview');

            let html = '';
            if (count > 0 && count <= 99) {
                const first = '1';
                const last = count.toString();
                html = `
                    <div><strong>åœæœºä½æ•°é‡:</strong> ${count} ä¸ª</div>
                    <div><strong>ä»£å·èŒƒå›´:</strong> ${first} ~ ${last}</div>
                `;
            } else if (config.stands.length > 0) {
                html = `
                    <div><strong>å½“å‰å·²é…ç½®:</strong> ${config.stands.length} ä¸ªåœæœºä½</div>
                    <div><strong>ä»£å·èŒƒå›´:</strong> ${config.stands[0]} ~ ${config.stands[config.stands.length - 1]}</div>
                `;
            } else {
                html = `<div><strong>å½“å‰çŠ¶æ€:</strong> æœªé…ç½®åœæœºä½</div>`;
            }

            // æ·»åŠ ä½¿ç”¨çŠ¶å†µç»Ÿè®¡
            const stats = getStandUsageStats();
            const sortNum = (a, b) => parseInt(a) - parseInt(b);

            if (stats.arrivals.size > 0 || stats.departures.size > 0) {
                // ç”Ÿæˆå…ˆå‡ºåè¿›çš„å¯ç‚¹å‡»æ ‡ç­¾
                const turnaroundBadges = [...stats.turnarounds].sort(sortNum)
                    .map(s => `<span class="turnaround-badge" onmouseenter="highlightTurnaround('${s}')" onmouseleave="unhighlightTurnaround('${s}')">${s}</span>`)
                    .join('') || '<span style="color: #888;">æ— </span>';

                html += `
                    <hr style="border-color: #444; margin: 12px 0;">
                    <div style="margin-bottom: 6px;"><strong>ğŸ“Š ä½¿ç”¨çŠ¶å†µ:</strong></div>
                    <div>æœ‰åˆ°è¾¾: ${stats.arrivals.size} ä¸ª <span style="color: #888;">(${[...stats.arrivals].sort(sortNum).join(', ') || 'æ— '})</span></div>
                    <div>æœ‰å‡ºå‘: ${stats.departures.size} ä¸ª <span style="color: #888;">(${[...stats.departures].sort(sortNum).join(', ') || 'æ— '})</span></div>
                    <div>å…ˆå‡ºåè¿›: ${stats.turnarounds.size} ä¸ª ${turnaroundBadges}</div>
                `;
            }

            previewEl.innerHTML = html;
        }

        // å…ˆå‡ºåè¿›åœæœºä½é«˜äº®
        function highlightTurnaround(stand) {
            if (!stand) return;
            document.querySelectorAll('#tableBody tr').forEach(tr => {
                const idx = parseInt(tr.dataset.index);
                const flight = allFlights[idx];
                if (flight && flight.stand === stand) {
                    tr.classList.add('highlight-turnaround');
                }
            });
        }

        function unhighlightTurnaround(stand) {
            document.querySelectorAll('tr.highlight-turnaround').forEach(el => {
                el.classList.remove('highlight-turnaround');
            });
        }

        async function applyAirportInfo() {
            const count = parseInt(document.getElementById('standCount').value);

            if (isNaN(count) || count < 1 || count > 99) {
                await showAlertModal('è¯·è¾“å…¥æœ‰æ•ˆçš„åœæœºä½æ•°é‡ (1-99)', 'warning');
                return;
            }

            // ç”Ÿæˆåœæœºä½ä»£å·
            config.stands = [];
            for (let i = 1; i <= count; i++) {
                config.stands.push(i.toString());
            }

            closeAirportInfoModal();
            renderTable();
            showStatus(`å·²ç”Ÿæˆ ${count} ä¸ªåœæœºä½ (01 ~ ${count.toString().padStart(2, '0')})`);
        }
    </script>
</body>

</html>