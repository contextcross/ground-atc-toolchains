<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATC CallSign Voice Generator</title>
    <style>
        /* CSS Variables - WinUI 3 Dark Theme Palette */
        :root {
            --bg-color: #202020;
            --card-bg: #2d2d2d;
            --accent-color: #0078d4;
            --accent-hover: #006cc1;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --border-color: #454545;
            --input-bg: #333333;
            --success-color: #107c10;
            --error-color: #c50f1f;
            --warning-color: #d83b01;
            --font-family: "Segoe UI", system-ui, sans-serif;
            --radius-std: 8px;
            --radius-sm: 4px;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-primary);
            margin: 0;
            padding: 20px;
            height: 100vh;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Utility Classes */
        .flex {
            display: flex;
        }

        .flex-col {
            flex-direction: column;
        }

        .gap-2 {
            gap: 8px;
        }

        .gap-4 {
            gap: 16px;
        }

        .items-center {
            align-items: center;
        }

        .justify-between {
            justify-content: space-between;
        }

        .flex-1 {
            flex: 1;
        }

        .hidden {
            display: none !important;
        }

        /* Typography */
        h1 {
            margin: 0;
            font-size: 24px;
            font-weight: 600;
        }

        h2 {
            margin: 0;
            font-size: 18px;
            font-weight: 500;
        }

        .text-sm {
            font-size: 12px;
        }

        .text-sec {
            color: var(--text-secondary);
        }

        /* Components */
        button {
            background-color: var(--card-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 6px 16px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        button:hover {
            background-color: #3d3d3d;
        }

        button:active {
            background-color: #454545;
        }

        button.primary {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }

        button.primary:hover {
            background-color: var(--accent-hover);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        select,
        input[type="text"],
        input[type="password"] {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            /* Updated bottom border to full border */
            border-bottom: 2px solid var(--border-color);
            color: var(--text-primary);
            padding: 6px 8px;
            border-radius: var(--radius-sm);
            outline: none;
            font-family: inherit;
        }

        select:focus,
        input:focus {
            border-bottom-color: var(--accent-color);
        }

        /* Layout Area */
        .header-bar {
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        .control-panel {
            background-color: var(--card-bg);
            padding: 16px;
            border-radius: var(--radius-std);
            margin-bottom: 16px;
        }

        .main-content {
            background-color: var(--card-bg);
            border-radius: var(--radius-std);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            flex: 1;
            position: relative;
        }

        /* Data Table */
        .table-container {
            flex: 1;
            overflow-y: auto;
            position: relative;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            text-align: left;
        }

        th {
            position: sticky;
            top: 0;
            background-color: #353535;
            /* Slightly lighter than card */
            padding: 12px;
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
            z-index: 10;
        }

        td {
            padding: 10px 12px;
            border-bottom: 1px solid #3d3d3d;
        }

        tr:hover td {
            background-color: #383838;
        }

        tr.selected td {
            background-color: rgba(0, 120, 212, 0.3);
            /* Accent transparent */
        }

        /* Status Badges */
        .badge {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            display: inline-block;
        }

        .badge-pending {
            background-color: #454545;
            color: #ccc;
        }

        .badge-processing {
            background-color: var(--accent-color);
            color: #fff;
        }

        .badge-completed {
            background-color: var(--success-color);
            color: #fff;
        }

        .badge-failed {
            background-color: var(--error-color);
            color: #fff;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }

        .modal {
            background: var(--card-bg);
            padding: 24px;
            border-radius: var(--radius-std);
            width: 400px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-color);
        }

        .modal-header {
            margin-bottom: 16px;
            font-size: 18px;
            font-weight: 600;
        }

        .modal-footer {
            margin-top: 24px;
            text-align: right;
        }

        /* Toast */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 2000;
        }

        .toast {
            background: var(--card-bg);
            border-left: 4px solid var(--accent-color);
            color: white;
            padding: 12px 16px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease-out;
            min-width: 200px;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Drop Area */
        .drop-area {
            border: 2px dashed var(--border-color);
            border-radius: var(--radius-std);
            padding: 20px;
            text-align: center;
            color: var(--text-secondary);
            transition: all 0.2s;
            cursor: pointer;
        }

        .drop-area:hover,
        .drop-area.drag-over {
            border-color: var(--accent-color);
            background: rgba(0, 120, 212, 0.1);
        }
    </style>
</head>

<body>

    <!-- Header -->
    <div class="header-bar flex items-center justify-between">
        <div class="flex items-center gap-4">
            <h1>ATC CallSign Voice Generator</h1>
            <span class="text-sec text-sm">v1.0.0</span>
        </div>
        <div class="flex gap-2">
            <button id="btnSettings">‚öôÔ∏è ËÆæÁΩÆ</button>
        </div>
    </div>

    <!-- Control Panel -->
    <div class="control-panel flex items-center justify-between gap-4">
        <div class="flex items-center gap-4 flex-1">
            <div class="flex flex-col gap-2">
                <label class="text-sm text-sec">È¢ÑËÆæ (Preset)</label>
                <select id="presetSelect" style="min-width: 200px;">
                    <!-- Options populated by JS -->
                </select>
            </div>

            <div class="flex flex-col gap-2 flex-1">
                <label class="text-sm text-sec">CSV Êñá‰ª∂ÂØºÂÖ•</label>
                <div id="dropArea" class="drop-area"
                    style="padding: 4px 12px; display: flex; align-items: center; justify-content: center;">
                    <span id="fileLabel">ÁÇπÂáªÊàñÊãñÊãΩ CSV Êñá‰ª∂Ëá≥Ê≠§</span>
                    <input type="file" id="csvInput" accept=".csv" hidden>
                </div>
            </div>
        </div>

        <div class="flex items-center gap-2" style="margin-top: 20px;">
            <button id="btnGenerateSelected" class="primary" disabled>üîä ÁîüÊàêÈÄâ‰∏≠</button>
            <button id="btnExportAll" disabled>üì• ÂØºÂá∫ÂÖ®ÈÉ®</button>
            <button id="btnClear">üóëÔ∏è Ê∏ÖÁ©∫</button>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="flex justify-between items-center" style="margin-bottom: 8px; padding: 0 4px;">
        <span class="text-sec text-sm" id="statusText">Á≠âÂæÖÂØºÂÖ•‰ªªÂä°...</span>
        <span class="text-sec text-sm" id="progressText"></span>
    </div>

    <!-- Main Table -->
    <div class="main-content">
        <div class="table-container">
            <table id="taskTable">
                <thead>
                    <tr>
                        <th width="80">Â∫èÂè∑</th>
                        <th width="150">ÂëºÂè∑ (CallSign)</th>
                        <th>ÁøªËØëÊñáÊú¨È¢ÑËßà (Text)</th>
                        <th width="120">Áä∂ÊÄÅ</th>
                        <th width="150">Êìç‰Ωú</th>
                    </tr>
                </thead>
                <tbody id="tableBody">
                    <!-- Rows populated by JS -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal-overlay hidden">
        <div class="modal">
            <div class="modal-header">ËÆæÁΩÆ</div>
            <div class="flex flex-col gap-4">
                <div class="flex flex-col gap-2">
                    <label class="text-sm">MiniMax API Key</label>
                    <input type="password" id="apiKeyInput" placeholder="ËæìÂÖ• API Key...">
                </div>
                <div class="flex flex-col gap-2">
                    <label class="text-sm">MiniMax Group ID</label>
                    <input type="text" id="groupIdInput" placeholder="ËæìÂÖ• Group ID (ÂèØÈÄâ)">
                </div>
                <div class="flex flex-col gap-2">
                    <label class="text-sm">API Endpoint (ÊúçÂä°Âô®Âå∫Âüü)</label>
                    <select id="apiEndpointSelect">
                        <option value="https://api.minimax.chat/v1/t2a_v2">ÂõΩÂÜÖÁâà (minimax.chat)</option>
                        <option value="https://api.minimaxi.com/v1/t2a_v2">ÂõΩÈôÖÁâà (minimaxi.com)</option>
                    </select>
                </div>
                <div class="flex flex-col gap-2">
                    <label class="text-sm">MiniMax Model (Ê®°ÂûãÁâàÊú¨)</label>
                    <select id="modelSelect">
                        <option value="speech-01-turbo">speech-01-turbo (ÈªòËÆ§)</option>
                        <option value="speech-01-hd">speech-01-hd</option>
                        <option value="speech-02-turbo">speech-02-turbo</option>
                        <option value="speech-02-hd">speech-02-hd</option>
                        <option value="speech-2.6-turbo">speech-2.6-turbo</option>
                        <option value="speech-2.6-hd">speech-2.6-hd</option>
                    </select>
                </div>
            </div>
            <div class="modal-footer flex gap-2 justify-between">
                <button id="btnCloseSettings">ÂÖ≥Èó≠</button>
                <button id="btnSaveSettings" class="primary">‰øùÂ≠ò</button>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div id="toastContainer" class="toast-container"></div>

    <script>
        /**
         * Logic Implementation with:
         * 1. Airline Mapping & Phonetic Translation
         * 2. Concurrency Control (Queue)
         * 3. UI Interaction
         */

        // --- Configuration & Constants ---

        const PRESETS = [
            // English Presets (Inferred)
            { id: "Aaron", name: "Aaron", lang: "en", voiceId: "Aaron", speed: 1, vol: 1, pitch: 0, emotion: "neutral" },
            { id: "Christopher", name: "Christopher", lang: "en", voiceId: "male-qn-domineering", speed: 1, vol: 1, pitch: 0, emotion: "neutral" },
            { id: "Fairy", name: "Fairy", lang: "en", voiceId: "female-shaonv", speed: 1.2, vol: 1, pitch: 0, emotion: "neutral" },

            // Chinese Presets (Specified)
            { id: "Hanser", name: "Hanser", lang: "zh", voiceId: "Chinese (Mandarin)_Crisp_Girl", speed: 1.35, vol: 1, pitch: 0, emotion: "neutral" },
            { id: "CN-Captain-Young", name: "CN-Captain-Young", lang: "zh", voiceId: "Chinese (Mandarin)_Radio_Host", speed: 1.2, vol: 0.5, pitch: 0, emotion: "neutral" },
            { id: "CN-Captain-Middle-Aged", name: "CN-Captain-Middle-Aged", lang: "zh", voiceId: "Chinese (Mandarin)_Reliable_Executive", speed: 1.2, vol: 0.5, pitch: -1, emotion: "neutral" },

            // Cross-Language / Variants (Inferred/Mapped)
            { id: "CN-Captain-Young-EN", name: "CN-Captain-Young-EN", lang: "en", voiceId: "Chinese (Mandarin)_Radio_Host", speed: 1.2, vol: 0.5, pitch: 0, emotion: "neutral" },
            { id: "Hanser-EN", name: "Hanser-EN", lang: "en", voiceId: "Chinese (Mandarin)_Crisp_Girl", speed: 1.35, vol: 1, pitch: 0, emotion: "neutral" }
        ];

        // Airline Data
        const AIRLINES = {
            "CCA": { zh: "ÂõΩËà™", en: "Air China" },
            "CES": { zh: "‰∏úÊñπ", en: "China Eastern" },
            "CSN": { zh: "ÂçóÊñπ", en: "China Southern" },
            "CHH": { zh: "Êµ∑Âçó", en: "Hainan" },
            "CDG": { zh: "ÊàêÈÉΩ", en: "Chengdu" },
            "CSC": { zh: "ÂõõÂ∑ù", en: "Sichuan Air" },
            "CXA": { zh: "ÁôΩÈπ≠", en: "Bailu Air" },
            "CQH": { zh: "Êò•Áßã", en: "Spring Air" },
            "CSZ": { zh: "Ê∑±Âú≥", en: "Shenzhen Air" }, // Duplicate in prompt?
            "CJX": { zh: "ÈïøÂÆâ", en: "Chang An" },
            "UEA": { zh: "ËÅîËà™", en: "United Eagle" }
        };

        const DIGIT_MAP_ZH = { '0': 'Ê¥û', '1': 'Âπ∫', '2': '‰∏§', '3': '‰∏â', '4': 'Âõõ', '5': '‰∫î', '6': 'ÂÖ≠', '7': 'Êãê', '8': 'ÂÖ´', '9': '‰πù' };

        // English digits are standard numbers, but prompt says "One", "Two" etc. 
        // We will just let TTS handle single digits, but "0" -> "Zero".
        const DIGIT_MAP_EN = { '0': 'Zero', '1': 'One', '2': 'Two', '3': 'Three', '4': 'Four', '5': 'Five', '6': 'Six', '7': 'Seven', '8': 'Eight', '9': 'Nine' };

        // --- State Management ---
        let appState = {
            apiKey: localStorage.getItem('minimax_api_key') || '',
            groupId: localStorage.getItem('minimax_group_id') || '',
            apiEndpoint: localStorage.getItem('minimax_api_endpoint') || 'https://api.minimax.chat/v1/t2a_v2',
            apiModel: localStorage.getItem('minimax_api_model') || 'speech-01-turbo',
            tasks: [], // { id, callSign, text, status, blob, error, presetId }
            processingCount: 0,
            queue: [], // IDs waiting
            currentPreset: PRESETS[2], // Default CN-Captain-Young
            selectedIds: new Set()
        };

        const MAX_CONCURRENCY = 3;

        // --- DOM Elements ---
        const els = {
            presetSelect: document.getElementById('presetSelect'),
            csvInput: document.getElementById('csvInput'),
            dropArea: document.getElementById('dropArea'),
            fileLabel: document.getElementById('fileLabel'),
            tableBody: document.getElementById('tableBody'),
            btnGenerateSelected: document.getElementById('btnGenerateSelected'),
            btnExportAll: document.getElementById('btnExportAll'),
            btnClear: document.getElementById('btnClear'),
            statusText: document.getElementById('statusText'),
            progressText: document.getElementById('progressText'),
            settingsModal: document.getElementById('settingsModal'),
            btnSettings: document.getElementById('btnSettings'),
            btnCloseSettings: document.getElementById('btnCloseSettings'),
            btnSaveSettings: document.getElementById('btnSaveSettings'),
            apiKeyInput: document.getElementById('apiKeyInput'),
            groupIdInput: document.getElementById('groupIdInput'),
            apiEndpointSelect: document.getElementById('apiEndpointSelect'),
            modelSelect: document.getElementById('modelSelect'),
            toastContainer: document.getElementById('toastContainer')
        };

        // --- Initialization ---
        function init() {
            // Populate Presets
            PRESETS.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p.id;
                opt.textContent = p.name;
                els.presetSelect.appendChild(opt);
            });
            els.presetSelect.value = appState.currentPreset.id;

            // Load API Key safely
            els.apiKeyInput.value = appState.apiKey;
            els.groupIdInput.value = appState.groupId;
            els.apiEndpointSelect.value = appState.apiEndpoint;
            els.modelSelect.value = appState.apiModel;

            // Event Listeners
            setupEventListeners();

            // Unload protection
            window.addEventListener('beforeunload', (e) => {
                const hasUnexported = appState.tasks.some(t => t.status === 'completed' && !t.exported);
                if (hasUnexported || appState.processingCount > 0) {
                    e.preventDefault();
                    e.returnValue = '';
                }
            });
        }

        function setupEventListeners() {
            // Settings
            els.btnSettings.onclick = () => els.settingsModal.classList.remove('hidden');
            els.btnCloseSettings.onclick = () => els.settingsModal.classList.add('hidden');
            els.btnSaveSettings.onclick = () => {
                const key = els.apiKeyInput.value.trim();
                const groupId = els.groupIdInput.value.trim();
                const endpoint = els.apiEndpointSelect.value;
                const model = els.modelSelect.value;

                if (key) {
                    appState.apiKey = key;
                    appState.groupId = groupId;
                    appState.apiEndpoint = endpoint;
                    appState.apiModel = model;

                    localStorage.setItem('minimax_api_key', key);
                    localStorage.setItem('minimax_group_id', groupId);
                    localStorage.setItem('minimax_api_endpoint', endpoint);
                    localStorage.setItem('minimax_api_model', model);

                    showToast('ËÆæÁΩÆÂ∑≤‰øùÂ≠ò', 'success');
                    els.settingsModal.classList.add('hidden');
                } else {
                    showToast('API Key ‰∏çËÉΩ‰∏∫Á©∫', 'error');
                }
            };

            // Preset Change
            els.presetSelect.onchange = () => {
                const pid = els.presetSelect.value;
                appState.currentPreset = PRESETS.find(p => p.id === pid);
                appState.selectedIds.clear();
                renderTable(); // Re-render with new preset view
            };

            // File Upload
            els.dropArea.onclick = () => els.csvInput.click();
            els.csvInput.onchange = (e) => handleFile(e.target.files[0]);

            // Drag & Drop
            els.dropArea.ondragover = (e) => { e.preventDefault(); els.dropArea.classList.add('drag-over'); };
            els.dropArea.ondragleave = () => els.dropArea.classList.remove('drag-over');
            els.dropArea.ondrop = (e) => {
                e.preventDefault();
                els.dropArea.classList.remove('drag-over');
                if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
            };

            // Actions
            els.btnGenerateSelected.onclick = startSelectedGeneration;
            els.btnExportAll.onclick = exportAll;
            els.btnClear.onclick = () => {
                if (confirm('Á°ÆÂÆöÊ∏ÖÁ©∫ÊâÄÊúâ‰ªªÂä°ÂêóÔºü(ËøôÂ∞ÜÂΩ±ÂìçÊâÄÊúâÈ¢ÑËÆæ)')) {
                    appState.tasks = []; // Clear all 
                    appState.queue = [];
                    appState.processingCount = 0;
                    appState.selectedIds.clear();
                    renderTable();
                    updateStatus();
                }
            };
        }

        // --- Core Logic: Parsing & Translation ---

        function handleFile(file) {
            if (!file) return;
            els.fileLabel.textContent = file.name;

            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                const lines = text.split(/\r?\n/);
                const newTasks = [];

                // Simple CSV parsing, assuming header might exist
                // Finding columns
                let callSignIdx = 0;
                let airlineIdx = -1; // Optional if we extract from callsign, but prompt says "Parsing logic: identify callSign and airline columns"

                const header = lines[0].toLowerCase().split(',');
                callSignIdx = header.findIndex(h => h.includes('callsign'));
                if (callSignIdx === -1) callSignIdx = 0; // Fallback to first col

                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    const cols = line.split(',');
                    const cs = cols[callSignIdx]?.trim();

                    if (cs) {
                        const newTask = {
                            id: Date.now() + i,
                            callSign: cs.toUpperCase(),
                            results: {} // Map: presetId -> { status, text, blob, exported, error }
                        };
                        newTasks.push(newTask);
                    }
                }

                appState.tasks = [...appState.tasks, ...newTasks];
                renderTable();
                showToast(`Â∑≤ÂØºÂÖ• ${newTasks.length} Êù°Âü∫Á°Ä‰ªªÂä° (ÊâÄÊúâÈ¢ÑËÆæÂÖ±‰∫´)`);
                updateStatus();
            };
            reader.readAsText(file);
        }

        function translateCallSign(callSign, lang) {
            // Regex to separate Letters and Numbers
            // e.g. CSN8733 -> CSN, 8733
            const match = callSign.match(/^([A-Z]+)(\d+.*)$/);
            if (!match) return callSign; // Fallback

            const code = match[1];
            const numberPart = match[2];

            const airline = AIRLINES[code];
            // If airline unknown, read letters directly? Or spell out?
            // Prompt doesn't specify unknown behavior. We'll spell letters.

            let airlineName = "";

            if (lang === 'zh') {
                airlineName = airline ? airline.zh : code;
                // Digits
                const digits = numberPart.split('').map(d => DIGIT_MAP_ZH[d] || d).join('');
                return `${airlineName}${digits}`;
            } else {
                // English
                airlineName = airline ? airline.en : code; // Or spell check? Code usually ok.
                // Digits with space
                const digits = numberPart.split('').map(d => DIGIT_MAP_EN[d] || d).join(' ');
                return `${airlineName} ${digits}`;
            }
        }

        // updateTablePreviews removed - no longer re-translating on switch

        // --- Rendering ---

        // --- Rendering ---

        function renderTable() {
            els.tableBody.innerHTML = '';

            // Show ALL tasks, but state is derived from currentPreset matches
            const currentPid = appState.currentPreset.id;

            appState.tasks.forEach((task, index) => {
                // Get or Init Result for this preset
                let result = task.results[currentPid];
                if (!result) {
                    // Virtual pending state
                    result = {
                        status: 'pending',
                        text: translateCallSign(task.callSign, appState.currentPreset.lang),
                        blob: null
                    };
                    // We don't save it to 'results' yet to keep memory clean? 
                    // Or we should just for caching text. 
                    // Let's compute text on fly for display if missing.
                }

                const tr = document.createElement('tr');

                // Status Badge logic
                let badgeClass = 'badge-pending';
                let statusLabel = 'Á≠âÂæÖ‰∏≠';
                if (result.status === 'processing') { badgeClass = 'badge-processing'; statusLabel = 'ÁîüÊàê‰∏≠...'; }
                else if (result.status === 'completed') { badgeClass = 'badge-completed'; statusLabel = 'Â∑≤ÂÆåÊàê'; }
                else if (result.status === 'failed') { badgeClass = 'badge-failed'; statusLabel = 'Â§±Ë¥•'; }

                // Actions logic: Need to pass Preset ID context? Or just Task ID.
                // Action handles finding the task and then looking up current preset.
                let actionsHtml = '';
                if (result.status === 'completed') {
                    // Play
                    actionsHtml = `
                        <button class="text-sm" onmousedown="event.stopPropagation()" onclick="playAudio('${task.id}')">‚ñ∂Ô∏è</button>
                    `;
                } else if (result.status === 'failed' || result.status === 'pending') {
                    // Retry or Remove
                    actionsHtml = `
                        <button class="text-sm" onmousedown="event.stopPropagation()" onclick="retryTask('${task.id}')">‚Üª</button>
                        <button class="text-sm" onmousedown="event.stopPropagation()" onclick="removeTask('${task.id}')">‚úñ</button>
                    `;
                }

                tr.innerHTML = `
                    <td>${index + 1}</td>
                    <td style="font-family: monospace; font-weight: bold;">${task.callSign}</td>
                    <td>${result.text || translateCallSign(task.callSign, appState.currentPreset.lang)}</td>
                    <td><span class="badge ${badgeClass}">${statusLabel}</span></td>
                    <td>${actionsHtml}</td>
                `;

                // Selection Logic
                if (appState.selectedIds.has(task.id)) {
                    tr.classList.add('selected');
                }

                // Click Handlers
                tr.onmousedown = (e) => handleRowClick(e, task.id);
                tr.oncontextmenu = (e) => {
                    if (e.shiftKey) {
                        e.preventDefault(); // Prevent context menu on Shift+Right
                    }
                };

                els.tableBody.appendChild(tr);
            });

            updateStatus();
        }

        function updateStatus() {
            // Stats for Current Preset
            const currentPid = appState.currentPreset.id;
            const total = appState.tasks.length;

            // Count status in current preset results
            let completed = 0;
            let failed = 0;

            appState.tasks.forEach(t => {
                const r = t.results[currentPid];
                if (r) {
                    if (r.status === 'completed') completed++;
                    if (r.status === 'failed') failed++;
                }
            });

            els.statusText.textContent = `ÊÄª‰ªªÂä°: ${total} | ÂΩìÂâçÈ¢ÑËÆæÁªüËÆ°`;
            els.progressText.textContent = `ÊàêÂäü: ${completed} / Â§±Ë¥•: ${failed} / ÊÄªËÆ°: ${total}`;

            // Button state relies on current selection in filter
            // const canGenerate = total > 0 && appState.apiKey && appState.selectedIds.size > 0; 
            // Actually button is bound to selection, which we cleared on mode switch.

            els.btnGenerateSelected.disabled = total === 0 || !appState.apiKey || appState.selectedIds.size === 0;
            els.btnGenerateSelected.textContent = `üîä ÁîüÊàêÈÄâ‰∏≠ (${appState.selectedIds.size})`;
            els.btnExportAll.disabled = completed === 0;

            if (appState.processingCount > 0) {
                els.statusText.textContent += ` | Ê≠£Âú®Â§ÑÁêÜ ${appState.processingCount} ‰∏™‰ªªÂä°...`;
            }
        }

        function showToast(msg, type = 'info') {
            const toast = document.createElement('div');
            toast.className = 'toast';
            if (type === 'error') toast.style.borderLeftColor = 'var(--error-color)';
            if (type === 'success') toast.style.borderLeftColor = 'var(--success-color)';
            toast.textContent = msg;
            els.toastContainer.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // --- Logic: Actions ---

        window.removeTask = (id) => {
            // Can't remove if processing
            const t = appState.tasks.find(x => x.id == id);
            if (t && t.status === 'processing') return;
            appState.tasks = appState.tasks.filter(x => x.id != id);
            renderTable();
        };

        window.retryTask = (id) => {
            const t = appState.tasks.find(x => x.id == id);
            if (!t) return;
            if (!appState.apiKey) { showToast('ËØ∑ÂÖàËÆæÁΩÆ API Key', 'error'); return; }

            // Reset status for current preset
            const currentPid = appState.currentPreset.id;
            if (!t.results[currentPid]) t.results[currentPid] = { blob: null };
            t.results[currentPid].status = 'pending';
            addToQueue(t, currentPid);
        };

        window.playAudio = (id) => {
            const t = appState.tasks.find(x => x.id == id);
            const currentPid = appState.currentPreset.id;
            const res = t && t.results[currentPid];
            if (res && res.blob) {
                const url = URL.createObjectURL(res.blob);
                const audio = new Audio(url);
                audio.play();
            }
        };

        // --- Selection Logic ---
        function handleRowClick(e, id) {
            // Left Click (0)
            if (e.button === 0) {
                if (e.shiftKey) {
                    // Shift + Left: Add to selection (Multi-select)
                    appState.selectedIds.add(id);
                } else {
                    // Normal Left: Select only this (Clear others)
                    // But if usage wants standard behavior: Ctrl for toggle. 
                    // User asked: "Shift+Left multi-select".
                    appState.selectedIds.clear();
                    appState.selectedIds.add(id);
                }
            }
            // Right Click (2)
            else if (e.button === 2) {
                if (e.shiftKey) {
                    // Shift + Right: Deselect
                    appState.selectedIds.delete(id);
                }
            }
            renderTable();
        }

        function startSelectedGeneration() {
            if (!appState.apiKey) {
                showToast('ËØ∑ÂÖàËÆæÁΩÆ API Key', 'error');
                els.settingsModal.classList.remove('hidden');
                return;
            }

            const currentPid = appState.currentPreset.id;

            // Find valid tasks in Selection
            const targets = appState.tasks.filter(t => {
                if (!appState.selectedIds.has(t.id)) return false;
                // Check status in CURRENT preset
                const res = t.results[currentPid];
                if (!res) return true; // Never run
                return res.status === 'pending' || res.status === 'failed' || !res.status;
            });

            if (targets.length === 0) {
                showToast('ÈÄâ‰∏≠È°π‰∏≠Ê≤°ÊúâÂæÖÂ§ÑÁêÜÁöÑ‰ªªÂä°', 'info');
                return;
            }

            showToast(`ÂºÄÂßãÂ§ÑÁêÜ ${targets.length} ‰∏™‰ªªÂä°...`);
            targets.forEach(t => addToQueue(t, currentPid));
        }

        function addToQueue(task, presetId) {
            // Avoid duplicates
            if (appState.queue.find(q => q.task.id === task.id && q.presetId === presetId)) return;

            // Check processing status
            const res = task.results[presetId];
            if (res && res.status === 'processing') return;

            appState.queue.push({ task, presetId });
            processQueue();
        }

        function processQueue() {
            if (appState.processingCount >= MAX_CONCURRENCY) return;
            if (appState.queue.length === 0) return;

            const item = appState.queue.shift();
            const { task, presetId } = item;

            // Initialize or update result object
            if (!task.results[presetId]) {
                task.results[presetId] = {
                    blob: null,
                    text: translateCallSign(task.callSign, PRESETS.find(p => p.id === presetId)?.lang || 'en')
                };
            }
            task.results[presetId].status = 'processing';

            appState.processingCount++;
            renderTable();

            // Call API
            generateAudio(task, presetId).finally(() => {
                appState.processingCount--;
                processQueue();
            });
        }

        // --- API Integration ---

        async function generateAudio(task, presetId) {
            const preset = PRESETS.find(p => p.id === presetId) || appState.currentPreset;
            const resObject = task.results[presetId];

            // Construct Payload
            const payload = {
                "model": appState.apiModel,
                "text": (resObject.text || translateCallSign(task.callSign, preset.lang)) + (preset.lang === 'zh' ? '„ÄÇ' : ''),
                "stream": false,
                "voice_setting": {
                    "voice_id": preset.voiceId,
                    "speed": preset.speed || 1,
                    "vol": preset.vol || 1,
                    "pitch": preset.pitch || 0,
                    "emotion": preset.emotion || "neutral"
                },
                "audio_setting": {
                    "sample_rate": 44100,
                    "bitrate": 128000,
                    "format": "wav",
                    "channel": 2 // Dual channel safe ? usually 1 or 2. User asked for 2.
                }
            };

            // Correction: The prompt model key might be for a specific endpoint. 
            // https://api.minimaxi.com/v1/t2a_v2 usually matches "speech-01-..." models.
            // I will use `speech-01-turbo` as it is faster and reliable for tools, 
            // but I will allow user to changing it in code easily if needed.
            // Actually, if I use the exact example from prompt:
            payload.model = "speech-01-turbo";

            try {
                // Use configured endpoint
                const url = new URL(appState.apiEndpoint);
                if (appState.groupId) {
                    url.searchParams.append("GroupId", appState.groupId);
                }

                const response = await fetch(url.toString(), {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${appState.apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const err = await response.text();
                    throw new Error(`API Error: ${response.status} - ${err}`);
                }

                const data = await response.json();

                // MiniMax V2 Response format check
                // Usually { base_resp: { status_code: 0 }, data: { audio: "hex..." } } or similar?
                // Or might be binary if steam? But stream=false.
                // NOTE: MiniMax T2A V2 usually returns JSON with "data": { "audio": "hex string" } or similar.

                if (data.base_resp && data.base_resp.status_code !== 0) {
                    throw new Error(`API Logic Error: ${data.base_resp.status_msg}`);
                }

                // Assuming data.data.audio is the hex string
                if (data.data && data.data.audio) {
                    const hex = data.data.audio;
                    // Convert Hex to Blob
                    const buffer = new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                    const blob = new Blob([buffer], { type: 'audio/wav' });

                    resObject.blob = blob;
                    resObject.status = 'completed';
                } else {
                    throw new Error("Invalid API Response Structure");
                }

            } catch (e) {
                console.error(e);
                resObject.status = 'failed';
                showToast(`Task ${task.callSign} Failed: ${e.message}`, 'error');
            } finally {
                renderTable();
            }
        }

        // --- Export ---

        async function exportAll() {
            // Collect all completed results for CURRENT preset
            const currentPid = appState.currentPreset.id;
            const validItems = [];

            appState.tasks.forEach(t => {
                const res = t.results[currentPid];
                if (res && res.status === 'completed' && res.blob) {
                    // Normalize blob name/item
                    validItems.push({ callSign: t.callSign, blob: res.blob, task: t });
                }
            });

            if (validItems.length === 0) {
                showToast('ÂΩìÂâçÈ¢ÑËÆæÊ≤°ÊúâÂèØÂØºÂá∫ÁöÑÂ∑≤ÂÆåÊàê‰ªªÂä°', 'info');
                return;
            }

            try {
                // 1. Open Directory Picker
                const dirHandle = await window.showDirectoryPicker();

                // 2. Create/Get Subfolder for Preset Name (Strict Match)
                const presetName = appState.currentPreset.name;
                const presetDir = await dirHandle.getDirectoryHandle(presetName, { create: true });

                showToast(`Ê≠£Âú®ÂØºÂá∫ ${validItems.length} ‰∏™Êñá‰ª∂...`);

                // 3. Write Files
                let savedCount = 0;
                for (const item of validItems) {
                    try {
                        const fileHandle = await presetDir.getFileHandle(`${item.callSign}.wav`, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(item.blob);
                        await writable.close();

                        // Mark as exported
                        item.task.results[currentPid].exported = true;
                        savedCount++;
                    } catch (e) {
                        console.error(`Failed to write ${item.callSign}`, e);
                        // Continue others
                    }
                }

                showToast(`(‚úÖ ÂØºÂá∫ÂÆåÊàê: ÊàêÂäü ${savedCount} / ÊÄªËÆ° ${validItems.length}`);

            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error(err);
                    showToast(`ÂØºÂá∫Â§±Ë¥•: ${err.message}`, 'error');
                }
            }
        }



        // Run
        init();

    </script>
</body>

</html>