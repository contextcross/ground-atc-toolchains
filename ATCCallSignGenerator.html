<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATC CallSign Voice Generator</title>
    <script src="translation_rules.js"></script>
    <script src="voicename.js"></script>
    <style>
        /* CSS Variables - WinUI 3 Dark Theme Palette */
        :root {
            --bg-color: #202020;
            --card-bg: #2d2d2d;
            --accent-color: #0078d4;
            --accent-hover: #006cc1;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --border-color: #454545;
            --input-bg: #333333;
            --success-color: #107c10;
            --error-color: #c50f1f;
            --warning-color: #d83b01;
            --font-family: "Segoe UI", system-ui, sans-serif;
            --radius-std: 8px;
            --radius-sm: 4px;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-primary);
            margin: 0;
            padding: 20px;
            height: 100vh;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Utility Classes */
        .flex {
            display: flex;
        }

        .flex-col {
            flex-direction: column;
        }

        .gap-2 {
            gap: 8px;
        }

        .gap-4 {
            gap: 16px;
        }

        .items-center {
            align-items: center;
        }

        .justify-between {
            justify-content: space-between;
        }

        .flex-1 {
            flex: 1;
        }

        .hidden {
            display: none !important;
        }

        /* Typography */
        h1 {
            margin: 0;
            font-size: 24px;
            font-weight: 600;
        }

        h2 {
            margin: 0;
            font-size: 18px;
            font-weight: 500;
        }

        .text-sm {
            font-size: 12px;
        }

        .text-sec {
            color: var(--text-secondary);
        }

        /* Components */
        button {
            background-color: var(--card-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 6px 16px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        button:hover {
            background-color: #3d3d3d;
        }

        button:active {
            background-color: #454545;
        }

        button.primary {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }

        button.primary:hover {
            background-color: var(--accent-hover);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        select,
        input[type="text"],
        input[type="password"] {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            /* Updated bottom border to full border */
            border-bottom: 2px solid var(--border-color);
            color: var(--text-primary);
            padding: 6px 8px;
            border-radius: var(--radius-sm);
            outline: none;
            font-family: inherit;
        }

        select:focus,
        input:focus {
            border-bottom-color: var(--accent-color);
        }

        /* Layout Area */
        .header-bar {
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        .control-panel {
            background-color: var(--card-bg);
            padding: 16px;
            border-radius: var(--radius-std);
            margin-bottom: 16px;
        }

        .main-content {
            background-color: var(--card-bg);
            border-radius: var(--radius-std);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            flex: 1;
            position: relative;
        }

        /* Data Table */
        .table-container {
            flex: 1;
            overflow-y: auto;
            position: relative;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            text-align: left;
        }

        th {
            position: sticky;
            top: 0;
            background-color: #353535;
            /* Slightly lighter than card */
            padding: 12px;
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
            z-index: 10;
        }

        td {
            padding: 10px 12px;
            border-bottom: 1px solid #3d3d3d;
        }

        tr:hover td {
            background-color: #383838;
        }

        tr.selected td {
            background-color: rgba(0, 120, 212, 0.3);
            /* Accent transparent */
        }

        /* Status Badges */
        .badge {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            display: inline-block;
        }

        .badge-pending {
            background-color: #454545;
            color: #ccc;
        }

        .badge-processing {
            background-color: var(--accent-color);
            color: #fff;
        }

        .badge-completed {
            background-color: #ff9800;
            /* Orange */
            color: #fff;
        }

        .badge-edited {
            background-color: #00a200;
            /* Green */
            color: #fff;
        }

        .badge-failed {
            background-color: var(--error-color);
            color: #fff;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }

        .modal {
            background: var(--card-bg);
            padding: 24px;
            border-radius: var(--radius-std);
            width: 400px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-color);
        }

        .modal-header {
            margin-bottom: 16px;
            font-size: 18px;
            font-weight: 600;
        }

        .modal-footer {
            margin-top: 24px;
            text-align: right;
        }

        /* Toast */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 2000;
        }

        .toast {
            background: var(--card-bg);
            border-left: 4px solid var(--accent-color);
            color: white;
            padding: 12px 16px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease-out;
            min-width: 200px;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Drop Area */
        .drop-area {
            border: 2px dashed var(--border-color);
            border-radius: var(--radius-std);
            padding: 20px;
            text-align: center;
            color: var(--text-secondary);
            transition: all 0.2s;
            cursor: pointer;
        }

        .drop-area:hover,
        .drop-area.drag-over {
            border-color: var(--accent-color);
            background: rgba(0, 120, 212, 0.1);
        }

        /* Tab Bar */
        .tab-bar {
            display: flex;
            gap: 4px;
            padding: 8px 12px;
            background: #252525;
            border-radius: var(--radius-std) var(--radius-std) 0 0;
            overflow-x: auto;
        }

        .tab-item {
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            white-space: nowrap;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .tab-item:hover {
            background: #3a3a3a;
        }

        .tab-item.active {
            background: var(--accent-color);
            color: white;
        }

        .tab-count {
            margin-left: 4px;
            font-size: 11px;
            opacity: 0.7;
        }
    </style>
</head>

<body>

    <!-- Header -->
    <div class="header-bar flex items-center justify-between">
        <div class="flex items-center gap-4">
            <h1>ATC CallSign Voice Generator</h1>
            <span class="text-sec text-sm">v1.0.0</span>
        </div>
        <div class="flex gap-2">
            <button id="btnSettings">âš™ï¸ è®¾ç½®</button>
        </div>
    </div>

    <!-- Control Panel -->
    <div class="control-panel flex items-center justify-between gap-4">
        <div class="flex items-center gap-4 flex-1">
            <div class="flex flex-col gap-2">
                <label class="text-sm text-sec">é¢„è®¾ (Preset)</label>
                <select id="presetSelect" style="min-width: 200px;">
                    <!-- Options populated by JS -->
                </select>
            </div>

            <div class="flex flex-col gap-2 flex-1">
                <label class="text-sm text-sec">æ•°æ®æ–‡ä»¶å¯¼å…¥</label>
                <div id="dropArea" class="drop-area"
                    style="padding: 4px 12px; display: flex; align-items: center; justify-content: center;">
                    <span id="fileLabel">ç‚¹å‡»æˆ–æ‹–æ‹½ CSV/JSON æ–‡ä»¶è‡³æ­¤</span>
                    <input type="file" id="csvInput" accept=".csv,.json" hidden>
                </div>
            </div>
        </div>

        <div class="flex items-center gap-2" style="margin-top: 20px;">
            <button id="btnGenerateSelected" class="primary" disabled>ğŸ”Š ç”Ÿæˆé€‰ä¸­</button>
            <button id="btnExportAll" disabled>ğŸ“¥ å¯¼å‡ºç›®å½•</button>
            <button id="btnCleanup" disabled title="åˆ é™¤å·²å­˜åœ¨çš„ä»»åŠ¡ï¼Œä»…ä¿ç•™ç¼ºå¤±ä»»åŠ¡">ğŸ§¹ æ¸…ç†</button>
            <button id="btnClear">ğŸ—‘ï¸ æ¸…ç©º</button>
        </div>
    </div>

    <!-- Type Tabs -->
    <div class="tab-bar" id="typeTabBar"></div>

    <!-- Status Bar -->
    <div class="flex justify-between items-center" style="margin-bottom: 8px; padding: 0 4px;">
        <span class="text-sec text-sm" id="statusText">ç­‰å¾…å¯¼å…¥ä»»åŠ¡...</span>
        <span class="text-sec text-sm" id="progressText"></span>
    </div>

    <!-- Main Table -->
    <div class="main-content">
        <div class="table-container">
            <table id="taskTable">
                <thead>
                    <tr>
                        <th width="80">åºå·</th>
                        <th width="150">åç§° (Name)</th>
                        <th>æ–‡æœ¬é¢„è§ˆ (Text)</th>
                        <th width="120">çŠ¶æ€</th>
                        <th width="150">æ“ä½œ</th>
                    </tr>
                </thead>
                <tbody id="tableBody">
                    <!-- Rows populated by JS -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal-overlay hidden">
        <div class="modal">
            <div class="modal-header">è®¾ç½®</div>
            <div class="flex flex-col gap-4">
                <!-- MiniMax Settings -->
                <div style="border-bottom: 1px solid #444; padding-bottom: 12px;">
                    <h4 style="margin: 0 0 12px 0; color: #0078d4;">MiniMax TTS</h4>
                    <div class="flex flex-col gap-2 mb-3">
                        <label class="text-sm">API Key</label>
                        <input type="password" id="apiKeyInput" placeholder="è¾“å…¥ API Key...">
                    </div>
                    <div class="flex flex-col gap-2 mb-3">
                        <label class="text-sm">Group ID</label>
                        <input type="text" id="groupIdInput" placeholder="è¾“å…¥ Group ID (å¯é€‰)">
                    </div>
                    <div class="flex flex-col gap-2 mb-3">
                        <label class="text-sm">API Endpoint (æœåŠ¡å™¨åŒºåŸŸ)</label>
                        <select id="apiEndpointSelect">
                            <option value="https://api.minimax.chat/v1/t2a_v2">å›½å†…ç‰ˆ (minimax.chat)</option>
                            <option value="https://api.minimaxi.com/v1/t2a_v2">å›½é™…ç‰ˆ (minimaxi.com)</option>
                        </select>
                    </div>
                    <div class="flex flex-col gap-2">
                        <label class="text-sm">Model (æ¨¡å‹ç‰ˆæœ¬)</label>
                        <select id="modelSelect">
                            <option value="speech-01-turbo">speech-01-turbo (é»˜è®¤)</option>
                            <option value="speech-01-hd">speech-01-hd</option>
                            <option value="speech-02-turbo">speech-02-turbo</option>
                            <option value="speech-02-hd">speech-02-hd</option>
                            <option value="speech-2.6-turbo">speech-2.6-turbo</option>
                            <option value="speech-2.6-hd">speech-2.6-hd</option>
                        </select>
                    </div>
                </div>

                <!-- ElevenLabs Settings -->
                <div>
                    <h4 style="margin: 0 0 12px 0; color: #10a37f;">ElevenLabs TTS</h4>
                    <div class="flex flex-col gap-2 mb-3">
                        <label class="text-sm">API Key</label>
                        <input type="password" id="elevenlabsApiKeyInput" placeholder="sk_...">
                    </div>
                    <div class="flex flex-col gap-2">
                        <label class="text-sm">Model</label>
                        <select id="elevenlabsModelSelect">
                            <option value="eleven_v3">v3</option>
                            <option value="eleven_multilingual_v2">Multilingual v2</option>
                            <option value="eleven_turbo_v2_5">Turbo v2.5</option>
                            <option value="eleven_turbo_v2">Turbo v2</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="modal-footer flex gap-2 justify-between">
                <button id="btnCloseSettings">å…³é—­</button>
                <button id="btnSaveSettings" class="primary">ä¿å­˜</button>
            </div>
        </div>
    </div>

    <!-- Confirm Modal -->
    <div id="confirmModal" class="modal-overlay hidden" style="z-index: 2000;">
        <div class="modal" style="width: 400px; max-width: 90vw;">
            <div class="modal-header">æç¤º (Warning)</div>
            <div id="confirmMessage" class="text-sm"
                style="white-space: pre-wrap; margin-bottom: 24px; color: #ddd; line-height: 1.5;"></div>
            <div class="modal-footer flex gap-2 justify-end">
                <button id="btnConfirmCancel">å–æ¶ˆ</button>
                <button id="btnConfirmOk" class="primary">ç¡®å®š (Continue)</button>
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div id="exportModal" class="modal-overlay hidden" style="z-index: 1500;">
        <div class="modal" style="width: 450px; max-width: 90vw;">
            <div class="modal-header">ğŸ“¥ å¯¼å‡ºéŸ³é¢‘</div>

            <!-- Directory Picker -->
            <div id="exportDirDropzone" class="dropzone"
                style="background: #1a1a1a; border: 2px dashed #555; border-radius: 8px; min-height: 100px; display: flex; align-items: center; justify-content: center; cursor: pointer; color: #888; transition: all 0.2s; margin-bottom: 16px;">
                <span id="exportDirLabel">ğŸ“ ç‚¹å‡»é€‰æ‹©å¯¼å‡ºç›®å½•</span>
            </div>

            <!-- Integrity Check Results -->
            <div id="integrityCheckResults" style="display: none; margin-bottom: 16px;">
                <div class="text-sm" style="color: #888; margin-bottom: 8px;">ğŸ“Š èµ„äº§å®Œæ•´æ€§æ£€æŸ¥</div>
                <div id="integrityStats" class="text-sm"
                    style="background: #2a2a2a; padding: 12px; border-radius: 4px; max-height: 200px; overflow-y: auto;">
                    <!-- åŠ¨æ€å¡«å…… -->
                </div>
            </div>

            <!-- Export Options -->
            <div class="modal-footer flex gap-2 justify-end">
                <button id="btnExportUnnecessary"
                    style="background: #f9a825; color: #000; font-size: 13px; white-space: nowrap;" disabled>ğŸ“‹
                    å¯¼å‡ºå¤šä½™</button>
                <button id="btnExportCancel">å–æ¶ˆ</button>
                <button id="btnExportCurrentPreset" class="primary" disabled>å¯¼å‡ºå½“å‰é¢„è®¾</button>
                <button id="btnExportAllPresets" class="secondary" disabled>å¯¼å‡ºå…¨éƒ¨é¢„è®¾</button>
            </div>
        </div>
    </div>

    <!-- Audio Editor Modal -->
    <div id="audioEditorModal" class="modal-overlay hidden">
        <div class="modal" style="width: 700px; max-width: 95vw;">
            <div class="modal-header flex justify-between items-center">
                <div class="flex items-center gap-2">
                    <span>éŸ³é¢‘ç¼–è¾‘å™¨ - </span>
                    <span id="editorFileName"></span>
                </div>
                <div class="flex gap-4 items-center">
                    <label class="flex items-center gap-1 text-sm" style="cursor: pointer;">
                        <input type="checkbox" id="checkAutoSaveParams" style="width: 14px; height: 14px;">
                        è‡ªåŠ¨åº”ç”¨å‚æ•°
                    </label>
                    <div class="flex gap-2">
                        <button id="btnPrevTask" class="text-sm" title="ä¸Šä¸€æ¡">â—€</button>
                        <button id="btnNextTask" class="text-sm" title="ä¸‹ä¸€æ¡">â–¶</button>
                    </div>
                </div>
            </div>

            <!-- Waveform Container -->
            <div id="waveform" class="mb-4" style="background: #000; border-radius: 4px; border: 1px solid #444;"></div>

            <!-- Reference Audio Section -->
            <div class="reference-section mb-4">
                <div class="flex justify-between items-center mb-2">
                    <label class="text-sm" style="color: #ff9800;">å‚è€ƒéŸ³é¢‘ (Reference)</label>
                    <button id="btnClearRef" class="text-sm" style="padding: 2px 8px; display: none;">âœ– æ¸…é™¤</button>
                </div>
                <!-- Dropzone (shown when no ref audio) -->
                <div id="refDropzone" class="dropzone"
                    style="background: #1a1a1a; border: 2px dashed #555; border-radius: 4px; min-height: 90px; display: flex; align-items: center; justify-content: center; cursor: pointer; color: #888; transition: all 0.2s;">
                    <span>ç‚¹å‡»æˆ–æ‹–æ‹½å¯¼å…¥å‚è€ƒéŸ³é¢‘</span>
                </div>
                <!-- Waveform container (shown when ref audio loaded) -->
                <div id="waveformRef"
                    style="display: none; background: #1a1a1a; border: 1px solid #ff9800; border-radius: 4px;"></div>
                <input type="file" id="refFileInput" accept="audio/*" style="display: none;">
            </div>

            <!-- Controls (Split Layout) -->
            <div class="grid grid-cols-2 gap-4 mb-4"
                style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; background: #2a2a2a; padding: 16px; border-radius: 8px;">
                <!-- Left Column: Basic -->
                <div class="flex flex-col gap-4">
                    <h3 style="margin: 0 0 8px 0; font-size: 14px; border-bottom: 1px solid #444; padding-bottom: 4px;">
                        åŸºç¡€å‚æ•°</h3>
                    <div class="flex flex-col gap-2">
                        <label class="text-sm">éŸ³é‡ (Gain: <span id="valVol">0</span> dB)</label>
                        <input type="range" id="sliderVol" min="-20" max="20" step="1" value="0">
                    </div>
                    <div class="flex flex-col gap-2">
                        <label class="text-sm">è¯­é€Ÿ (Rate: <span id="valRate">1.0</span>x)</label>
                        <input type="range" id="sliderRate" min="0.5" max="2.0" step="0.1" value="1.0">
                    </div>
                    <div class="flex flex-col gap-2">
                        <label class="text-sm">éŸ³è°ƒ (Pitch: <span id="valPitch">0</span> cents)</label>
                        <input type="range" id="sliderPitch" min="-1200" max="1200" step="50" value="0">
                    </div>
                </div>

                <!-- Right Column: Effects -->
                <div class="flex flex-col gap-4">
                    <div class="flex justify-between items-center"
                        style="border-bottom: 1px solid #444; padding-bottom: 4px; margin-bottom: 8px;">
                        <h3 style="margin: 0; font-size: 14px;">æ— çº¿ç”µç‰¹æ•ˆ</h3>
                        <div class="flex items-center gap-2">
                            <input type="checkbox" id="checkRadio" style="width: 16px; height: 16px;">
                            <label for="checkRadio" class="text-sm cursor-pointer">å¯ç”¨</label>
                        </div>
                    </div>

                    <div id="radioFxControls" class="flex flex-col gap-3"
                        style="opacity: 0.5; pointer-events: none; transition: opacity 0.2s;">
                        <div class="flex flex-col gap-1">
                            <label class="text-sm text-sec">é«˜é€š (HPF: <span id="valHPF">300</span> Hz)</label>
                            <input type="range" id="sliderHighpass" min="0" max="1000" step="10" value="300">
                        </div>
                        <div class="flex flex-col gap-1">
                            <label class="text-sm text-sec">ä½é€š (LPF: <span id="valLPF">3500</span> Hz)</label>
                            <input type="range" id="sliderLowpass" min="1000" max="8000" step="100" value="3500">
                        </div>
                        <div class="flex flex-col gap-1">
                            <label class="text-sm text-sec">å¤±çœŸ (Dist: <span id="valDist">50</span>)</label>
                            <input type="range" id="sliderDistortion" min="0" max="100" step="1" value="50">
                        </div>
                    </div>
                </div>
            </div>

            <div class="modal-footer flex gap-2 justify-between">
                <div class="flex gap-2">
                    <button id="btnEditorPlay">â–¶ é¢„è§ˆ</button>
                    <button id="btnEditorReset">é‡ç½®</button>
                    <button id="btnDeleteRegion" disabled style="color: #ff6b6b;">âœ‚ åˆ é™¤é€‰ä¸­</button>
                </div>
                <div class="flex gap-2 items-center">
                    <select id="editorExportFormat"
                        class="p-2 border rounded bg-[var(--card-bg)] text-[var(--text-color)] border-[var(--border-color)] text-sm">
                        <option value="16">16-bit PCM (é»˜è®¤)</option>
                        <option value="32f">32-bit Float (æ¨è)</option>
                    </select>
                    <button id="btnEditorCancel">å–æ¶ˆ</button>
                    <button id="btnEditorSave" class="primary">ğŸ’¾ ä¿å­˜æ›´æ”¹</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div id="toastContainer" class="toast-container"></div>



    <!-- Wavesurfer.js (JSDelivr) -->


    <script>
        /**
         * Logic Implementation with:
         * 1. Airline Mapping & Phonetic Translation
         * 2. Concurrency Control (Queue)
         * 3. UI Interaction
         */


        // --- Configuration & Constants ---
        // VOICE_PRESETS loaded from voicename.js

        // --- State Management ---
        let appState = {
            apiKey: localStorage.getItem('minimax_api_key') || '',
            groupId: localStorage.getItem('minimax_group_id') || '',
            apiEndpoint: localStorage.getItem('minimax_api_endpoint') || 'https://api.minimax.chat/v1/t2a_v2',
            apiModel: localStorage.getItem('minimax_api_model') || 'speech-01-turbo',
            elevenlabsApiKey: localStorage.getItem('elevenlabs_api_key') || '',
            elevenlabsModel: localStorage.getItem('elevenlabs_model') || 'eleven_multilingual_v2',
            tasks: [], // { id, name, types, results }
            processingCount: 0,
            queue: [], // IDs waiting
            currentPreset: VOICE_PRESETS[5], // Default Hanser (zh)
            selectedIds: new Set(),
            lastRequestTime: 0, // Track last API call time for rate limiting
            currentTypeFilter: 'all', // Current type tab filter
            availableTypes: [], // Dynamically extracted from JSON
            currentLangFilter: null, // 'zh', 'en', or null for all
            translationRules: {}, // Loaded from translation_rules.json
            hiddenTasksByPreset: {}, // { [presetId]: Set<taskName> }
            savedEditorParams: null // { vol, rate, pitch, hpf, lpf, dist, radioEnabled }
        };

        const MAX_CONCURRENCY = 2; // Lowered from 3 to 2
        const REQUEST_INTERVAL = 300; // New: 300ms minimum interval between requests

        // Export State
        let exportState = {
            directoryHandle: null,
            directoryName: '',
            integrityResults: null, // { [presetName]: { missing: [], extra: [], total: number } }
            // Cache keys
            cachedTaskCount: 0,
            cachedTaskHash: '',
            cachedDirName: '',
            cachedLangFilter: null
        };

        // --- DOM Elements ---
        const els = {
            presetSelect: document.getElementById('presetSelect'),
            csvInput: document.getElementById('csvInput'),
            dropArea: document.getElementById('dropArea'),
            fileLabel: document.getElementById('fileLabel'),
            tableBody: document.getElementById('tableBody'),
            btnGenerateSelected: document.getElementById('btnGenerateSelected'),
            btnExportAll: document.getElementById('btnExportAll'),
            btnCleanup: document.getElementById('btnCleanup'),
            btnClear: document.getElementById('btnClear'),
            statusText: document.getElementById('statusText'),
            progressText: document.getElementById('progressText'),
            settingsModal: document.getElementById('settingsModal'),
            btnSettings: document.getElementById('btnSettings'),
            btnCloseSettings: document.getElementById('btnCloseSettings'),
            btnSaveSettings: document.getElementById('btnSaveSettings'),
            apiKeyInput: document.getElementById('apiKeyInput'),
            groupIdInput: document.getElementById('groupIdInput'),
            apiEndpointSelect: document.getElementById('apiEndpointSelect'),
            modelSelect: document.getElementById('modelSelect'),
            elevenlabsApiKeyInput: document.getElementById('elevenlabsApiKeyInput'),
            elevenlabsModelSelect: document.getElementById('elevenlabsModelSelect'),
            toastContainer: document.getElementById('toastContainer'),
            // Export Modal
            exportModal: document.getElementById('exportModal'),
            exportDirDropzone: document.getElementById('exportDirDropzone'),
            exportDirLabel: document.getElementById('exportDirLabel'),
            btnExportCurrentPreset: document.getElementById('btnExportCurrentPreset'),
            btnExportAllPresets: document.getElementById('btnExportAllPresets'),
            btnExportCancel: document.getElementById('btnExportCancel'),
            btnExportUnnecessary: document.getElementById('btnExportUnnecessary'),
            // Integrity Check
            integrityCheckResults: document.getElementById('integrityCheckResults'),
            integrityStats: document.getElementById('integrityStats')
        };

        // --- Initialization ---
        function init() {
            // Load translation rules from external JS file
            appState.translationRules = typeof TRANSLATION_RULES !== 'undefined' ? TRANSLATION_RULES : {};
            if (Object.keys(appState.translationRules).length > 0) {
                console.log('Translation rules loaded:', Object.keys(appState.translationRules));
            } else {
                console.warn('No translation rules found');
            }

            // Populate Presets
            VOICE_PRESETS.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p.id;
                opt.textContent = p.name;
                els.presetSelect.appendChild(opt);
            });
            els.presetSelect.value = appState.currentPreset.id;

            // Load API Key safely
            els.apiKeyInput.value = appState.apiKey;
            els.groupIdInput.value = appState.groupId;
            els.apiEndpointSelect.value = appState.apiEndpoint;
            els.modelSelect.value = appState.apiModel;
            els.elevenlabsApiKeyInput.value = appState.elevenlabsApiKey;
            els.elevenlabsModelSelect.value = appState.elevenlabsModel;

            // Event Listeners
            setupEventListeners();

            // Unload protection
            window.addEventListener('beforeunload', (e) => {
                const hasUnexported = appState.tasks.some(t => t.status === 'completed' && !t.exported);
                if (hasUnexported || appState.processingCount > 0) {
                    e.preventDefault();
                    e.returnValue = '';
                }
            });
        }

        // æ›´æ–°é¢„è®¾ä¸‹æ‹‰åˆ—è¡¨ï¼ˆæ ¹æ®è¯­è¨€ç­›é€‰ï¼‰
        function updatePresetSelect(lang = null) {
            els.presetSelect.innerHTML = '';
            const filteredPresets = lang
                ? VOICE_PRESETS.filter(p => p.lang === lang)
                : VOICE_PRESETS;

            filteredPresets.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p.id;
                opt.textContent = `${p.name} (${p.lang.toUpperCase()})`;
                els.presetSelect.appendChild(opt);
            });

            // å¦‚æœå½“å‰é¢„è®¾ä¸åœ¨ç­›é€‰åˆ—è¡¨ä¸­ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ª
            if (!filteredPresets.find(p => p.id === appState.currentPreset.id)) {
                if (filteredPresets.length > 0) {
                    appState.currentPreset = filteredPresets[0];
                    els.presetSelect.value = filteredPresets[0].id;
                }
            } else {
                els.presetSelect.value = appState.currentPreset.id;
            }

            appState.currentLangFilter = lang;
        }

        function setupEventListeners() {
            // Settings
            els.btnSettings.onclick = () => els.settingsModal.classList.remove('hidden');
            els.btnCloseSettings.onclick = () => els.settingsModal.classList.add('hidden');
            els.btnSaveSettings.onclick = () => {
                const key = els.apiKeyInput.value.trim();
                const groupId = els.groupIdInput.value.trim();
                const endpoint = els.apiEndpointSelect.value;
                const model = els.modelSelect.value;
                const elevenlabsKey = els.elevenlabsApiKeyInput.value.trim();
                const elevenlabsModel = els.elevenlabsModelSelect.value;

                // Save MiniMax settings
                appState.apiKey = key;
                appState.groupId = groupId;
                appState.apiEndpoint = endpoint;
                appState.apiModel = model;
                localStorage.setItem('minimax_api_key', key);
                localStorage.setItem('minimax_group_id', groupId);
                localStorage.setItem('minimax_api_endpoint', endpoint);
                localStorage.setItem('minimax_api_model', model);

                // Save ElevenLabs settings
                appState.elevenlabsApiKey = elevenlabsKey;
                appState.elevenlabsModel = elevenlabsModel;
                localStorage.setItem('elevenlabs_api_key', elevenlabsKey);
                localStorage.setItem('elevenlabs_model', elevenlabsModel);

                showToast('è®¾ç½®å·²ä¿å­˜', 'success');
                els.settingsModal.classList.add('hidden');
            };

            // Preset Change
            els.presetSelect.onchange = () => {
                const pid = els.presetSelect.value;
                appState.currentPreset = VOICE_PRESETS.find(p => p.id === pid);
                appState.selectedIds.clear();
                renderTable(); // Re-render with new preset view
                renderIntegrityResults(); // Sync integrity panel highlight
                updateExportUnnecessaryButton(); // Update export button state
            };

            // File Upload
            els.dropArea.onclick = () => els.csvInput.click();
            els.csvInput.onchange = (e) => handleFile(e.target.files[0]);

            // Drag & Drop
            els.dropArea.ondragover = (e) => { e.preventDefault(); els.dropArea.classList.add('drag-over'); };
            els.dropArea.ondragleave = () => els.dropArea.classList.remove('drag-over');
            els.dropArea.ondrop = (e) => {
                e.preventDefault();
                els.dropArea.classList.remove('drag-over');
                if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
            };

            // Actions
            els.btnGenerateSelected.onclick = startSelectedGeneration;
            els.btnExportAll.onclick = openExportModal;
            els.btnClear.onclick = async () => {
                if (await showConfirmModal('ç¡®å®šæ¸…ç©ºæ‰€æœ‰ä»»åŠ¡å—ï¼Ÿ(è¿™å°†å½±å“æ‰€æœ‰é¢„è®¾)')) {
                    appState.tasks = []; // Clear all 
                    appState.queue = [];
                    appState.processingCount = 0;
                    appState.selectedIds.clear();
                    renderTable();
                    updateStatus();
                }
            };

            // Export Modal Listeners
            els.exportDirDropzone.onclick = selectExportDirectory;
            els.btnExportCancel.onclick = closeExportModal;
            els.btnExportCurrentPreset.onclick = () => executeExport('current');
            els.btnExportAllPresets.onclick = () => executeExport('all');
            els.btnExportUnnecessary.onclick = exportUnnecessaryAssets;

            // Cleanup button
            els.btnCleanup.onclick = cleanupExistingTasks;
        }

        // --- Core Logic: Parsing & Translation ---

        function handleFile(file) {
            if (!file) return;
            els.fileLabel.textContent = file.name;

            // æ£€æµ‹æ–‡ä»¶åè¯­è¨€åç¼€
            const fileName = file.name.toLowerCase();
            let detectedLang = null;
            if (fileName.includes('_zh') || fileName.includes('_cn')) {
                detectedLang = 'zh';
            } else if (fileName.includes('_en')) {
                detectedLang = 'en';
            }

            // æ ¹æ®æ£€æµ‹åˆ°çš„è¯­è¨€æ›´æ–°é¢„è®¾ä¸‹æ‹‰åˆ—è¡¨
            if (detectedLang) {
                updatePresetSelect(detectedLang);
                showToast(`æ£€æµ‹åˆ° ${detectedLang.toUpperCase()} è¯­è¨€æ–‡ä»¶ï¼Œå·²è‡ªåŠ¨ç­›é€‰é¢„è®¾`);
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                let newTasks = [];

                // æ ¹æ®æ–‡ä»¶æ‰©å±•åé€‰æ‹©è§£ææ–¹å¼
                if (file.name.toLowerCase().endsWith('.json')) {
                    newTasks = parseJsonFile(text);
                } else {
                    newTasks = parseCsvFile(text);
                }

                // å»é‡ï¼šè¿‡æ»¤æ‰å·²å­˜åœ¨çš„ä»»åŠ¡
                const existingNames = new Set(appState.tasks.map(t => t.name));
                const uniqueNewTasks = newTasks.filter(t => !existingNames.has(t.name));
                const skipped = newTasks.length - uniqueNewTasks.length;

                appState.tasks = [...appState.tasks, ...uniqueNewTasks];
                renderTable();

                if (skipped > 0) {
                    showToast(`å·²å¯¼å…¥ ${uniqueNewTasks.length} æ¡æ–°ä»»åŠ¡ï¼Œè·³è¿‡ ${skipped} æ¡é‡å¤ä»»åŠ¡`);
                } else {
                    showToast(`å·²å¯¼å…¥ ${uniqueNewTasks.length} æ¡ä»»åŠ¡`);
                }
                updateStatus();
            };
            reader.readAsText(file);
        }

        // JSON è§£æå‡½æ•° - åŠ¨æ€æå–æ‰€æœ‰ types
        function parseJsonFile(text) {
            const newTasks = [];
            const typeSet = new Set(); // æ”¶é›†æ‰€æœ‰ type

            try {
                const data = JSON.parse(text);
                const clips = data.audioClips || [];

                clips.forEach((clip, i) => {
                    if (clip.types && clip.types.length > 0) {
                        // æ”¶é›† types
                        clip.types.forEach(t => typeSet.add(t));

                        newTasks.push({
                            id: Date.now() + i,
                            name: clip.name,
                            types: clip.types,
                            results: {}
                        });
                    }
                });

                // æ›´æ–°å¯ç”¨ç±»å‹åˆ—è¡¨ï¼ˆæŒ‰å­—æ¯æ’åºï¼‰
                appState.availableTypes = Array.from(typeSet).sort();

            } catch (err) {
                showToast('JSON è§£æå¤±è´¥: ' + err.message, 'error');
            }
            return newTasks;
        }

        // CSV è§£æå‡½æ•°
        function parseCsvFile(text) {
            const newTasks = [];
            const typeSet = new Set();
            const lines = text.split(/\r?\n/);

            // Simple CSV parsing, assuming header might exist
            let nameIdx = 0;
            let typeIdx = 1;

            const header = lines[0].toLowerCase().split(',');
            nameIdx = header.findIndex(h => h.includes('callsign') || h.includes('name'));
            if (nameIdx === -1) nameIdx = 0; // Fallback to first col

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                const cols = line.split(',');
                const type = cols[typeIdx]?.trim();
                if (!type) continue;

                const name = cols[nameIdx]?.trim();
                if (name) {
                    typeSet.add(type);
                    newTasks.push({
                        id: Date.now() + i,
                        name: name,
                        types: [type],
                        results: {}
                    });
                }
            }

            // Merge with existing types
            typeSet.forEach(t => {
                if (!appState.availableTypes.includes(t)) {
                    appState.availableTypes.push(t);
                }
            });
            appState.availableTypes.sort();

            return newTasks;
        }

        // --- é€šç”¨ç¿»è¯‘å™¨ ---

        /**
         * é€šç”¨ç¿»è¯‘å‡½æ•°ï¼šéå†ç±»å‹å®šä¹‰çš„å­—å…¸ä¾æ¬¡è¿›è¡Œæ›¿æ¢
         * @param {string} text - åŸå§‹æ–‡æœ¬
         * @param {object} typeRule - ç±»å‹è§„åˆ™ (åŒ…å« useDictionaries æ•°ç»„)
         * @param {string} lang - è¯­è¨€ ('zh' æˆ– 'en')
         * @returns {string} ç¿»è¯‘åçš„æ–‡æœ¬
         */
        function applyTranslation(text, typeRule, lang) {
            const dictionaries = appState.translationRules.dictionaries || {};
            const useDicts = typeRule.useDictionaries || [];

            let result = text;

            // ä¾æ¬¡åº”ç”¨æ¯ä¸ªå­—å…¸
            for (const dictName of useDicts) {
                const dict = dictionaries[dictName];
                if (!dict || !dict[lang]) continue;

                const langDict = dict[lang];
                // å¯¹æ¯ä¸ªå­—å…¸é¡¹è¿›è¡Œæ›¿æ¢
                for (const [key, value] of Object.entries(langDict)) {
                    result = result.split(key).join(value);
                }
            }

            return result;
        }

        /**
         * è·å–ä»»åŠ¡çš„æ˜¾ç¤ºæ–‡æœ¬ (é€šç”¨è°ƒåº¦å…¥å£)
         */
        function getDisplayText(task, lang) {
            if (!task.types || task.types.length === 0) {
                return task.name;
            }

            const types = appState.translationRules.types || {};

            // éå†ä»»åŠ¡ç±»å‹ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªæœ‰è§„åˆ™çš„ç±»å‹
            for (const type of task.types) {
                const typeRule = types[type];
                if (typeRule) {
                    // å¦‚æœæ²¡æœ‰å­—å…¸ï¼Œç›´æ¥è¿”å›åŸæ–‡
                    if (!typeRule.useDictionaries || typeRule.useDictionaries.length === 0) {
                        return task.name;
                    }
                    return applyTranslation(task.name, typeRule, lang);
                }
            }

            return task.name;
        }

        // --- Rendering ---

        // Tab Rendering
        function renderTypeTabs() {
            const tabBar = document.getElementById('typeTabBar');
            tabBar.innerHTML = '';
            tabBar.appendChild(createTabItem('all', 'å…¨éƒ¨', appState.tasks.length));
            appState.availableTypes.forEach(typeId => {
                const count = appState.tasks.filter(t => t.types && t.types.includes(typeId)).length;
                if (count > 0) {
                    tabBar.appendChild(createTabItem(typeId, typeId, count));
                }
            });
        }

        function createTabItem(id, name, count) {
            const tab = document.createElement('div');
            tab.className = `tab-item ${appState.currentTypeFilter === id ? 'active' : ''}`;
            tab.innerHTML = `${name}<span class="tab-count">(${count})</span>`;
            tab.onclick = () => {
                appState.currentTypeFilter = id;
                appState.selectedIds.clear();
                renderTypeTabs();
                renderTable();
            };
            return tab;
        }

        function renderTable() {
            els.tableBody.innerHTML = '';
            const currentPid = appState.currentPreset.id;

            const filteredTasks = appState.currentTypeFilter === 'all'
                ? appState.tasks
                : appState.tasks.filter(t => t.types && t.types.includes(appState.currentTypeFilter));

            // Filter out hidden tasks for current preset
            const hiddenSet = appState.hiddenTasksByPreset[currentPid] || new Set();
            const visibleTasks = filteredTasks.filter(t => !hiddenSet.has(t.name));

            visibleTasks.forEach((task, index) => {
                let result = task.results[currentPid];
                if (!result) {
                    result = {
                        status: 'pending',
                        text: getDisplayText(task, appState.currentPreset.lang),
                        blob: null
                    };
                }

                const tr = document.createElement('tr');

                let badgeClass = 'badge-pending';
                let statusLabel = 'ç­‰å¾…ä¸­';
                if (result.status === 'processing') { badgeClass = 'badge-processing'; statusLabel = 'ç”Ÿæˆä¸­...'; }
                else if (result.status === 'completed') { badgeClass = 'badge-completed'; statusLabel = 'å·²å®Œæˆ'; }
                else if (result.status === 'edited') { badgeClass = 'badge-edited'; statusLabel = 'å·²ç¼–è¾‘'; }
                else if (result.status === 'failed') { badgeClass = 'badge-failed'; statusLabel = 'å¤±è´¥'; }

                let actionsHtml = '';
                if (result.status === 'completed' || result.status === 'edited') {
                    actionsHtml = `
                        <button class="text-sm" onmousedown="event.stopPropagation()" onclick="playAudio('${task.id}')">â–¶ï¸</button>
                        <button class="text-sm" onmousedown="event.stopPropagation()" onclick="retryTask('${task.id}')">â†»</button>
                        <button class="text-sm" onmousedown="event.stopPropagation()" onclick="openAudioEditor('${task.id}')">ğŸ› ï¸</button>
                    `;
                } else if (result.status === 'failed' || result.status === 'pending') {
                    actionsHtml = `
                        <button class="text-sm" onmousedown="event.stopPropagation()" onclick="retryTask('${task.id}')">â†»</button>
                        <button class="text-sm" onmousedown="event.stopPropagation()" onclick="removeTask('${task.id}')">âœ–</button>
                    `;
                }

                tr.innerHTML = `
                    <td>${index + 1}</td>
                    <td style="font-family: monospace; font-weight: bold;">${task.name}</td>
                    <td>${result.text || getDisplayText(task, appState.currentPreset.lang)}</td>
                    <td><span class="badge ${badgeClass}">${statusLabel}</span></td>
                    <td>${actionsHtml}</td>
                `;

                if (appState.selectedIds.has(task.id)) {
                    tr.classList.add('selected');
                }

                // Highlight missing tasks (based on integrity check)
                const presetName = appState.currentPreset.name;
                const integrityResult = exportState.integrityResults?.[presetName];
                if (integrityResult && integrityResult.missing.includes(task.name)) {
                    tr.style.background = 'rgba(255, 107, 107, 0.2)';
                    tr.style.borderLeft = '3px solid #ff6b6b';
                }

                tr.onmousedown = (e) => handleRowClick(e, task.id);
                tr.oncontextmenu = (e) => {
                    if (e.shiftKey) {
                        e.preventDefault();
                    }
                };

                els.tableBody.appendChild(tr);
            });

            renderTypeTabs();
            updateStatus();
        }

        function updateStatus() {
            // Stats for Current Preset
            const currentPid = appState.currentPreset.id;
            const total = appState.tasks.length;

            // Count status in current preset results
            let completed = 0;
            let failed = 0;

            appState.tasks.forEach(t => {
                const r = t.results[currentPid];
                if (r) {
                    if (r.status === 'completed') completed++;
                    if (r.status === 'failed') failed++;
                }
            });

            els.statusText.textContent = `æ€»ä»»åŠ¡: ${total} | å½“å‰é¢„è®¾ç»Ÿè®¡`;
            els.progressText.textContent = `æˆåŠŸ: ${completed} / å¤±è´¥: ${failed} / æ€»è®¡: ${total}`;

            // Button state relies on current selection in filter
            // const canGenerate = total > 0 && appState.apiKey && appState.selectedIds.size > 0; 
            // Actually button is bound to selection, which we cleared on mode switch.

            // Check API Key based on current preset's provider
            const hasApiKey = appState.currentPreset.provider === 'elevenlabs'
                ? !!appState.elevenlabsApiKey
                : !!appState.apiKey;
            els.btnGenerateSelected.disabled = total === 0 || !hasApiKey || appState.selectedIds.size === 0;
            els.btnGenerateSelected.textContent = `ğŸ”Š ç”Ÿæˆé€‰ä¸­ (${appState.selectedIds.size})`;
            els.btnExportAll.disabled = (completed + failed) === 0; // Or just completed? 
            // In the previous code, completed was counted. Let's update count to include edited.

            // Re-counting to include 'edited'
            let totalSuccess = 0;
            appState.tasks.forEach(t => {
                const r = t.results[currentPid];
                if (r && (r.status === 'completed' || r.status === 'edited')) totalSuccess++;
            });
            // Export button enabled if there are any tasks (not just completed ones)
            els.btnExportAll.disabled = appState.tasks.length === 0;

            // Cleanup button: enabled only if integrity check has been performed for current preset
            const currentPresetName = appState.currentPreset.name;
            const hasIntegrityResult = exportState.integrityResults?.[currentPresetName];
            els.btnCleanup.disabled = !hasIntegrityResult || appState.tasks.length === 0;

            if (appState.processingCount > 0) {
                els.statusText.textContent += ` | æ­£åœ¨å¤„ç† ${appState.processingCount} ä¸ªä»»åŠ¡...`;
            }
        }

        function showToast(msg, type = 'info') {
            const toast = document.createElement('div');
            toast.className = 'toast';
            if (type === 'error') toast.style.borderLeftColor = 'var(--error-color)';
            if (type === 'success') toast.style.borderLeftColor = 'var(--success-color)';
            toast.textContent = msg;
            els.toastContainer.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // --- Logic: Actions ---

        window.removeTask = (id) => {
            // Can't remove if processing
            const t = appState.tasks.find(x => x.id == id);
            if (t && t.status === 'processing') return;
            appState.tasks = appState.tasks.filter(x => x.id != id);
            renderTable();
        };

        function cleanupExistingTasks() {
            const presetId = appState.currentPreset.id;
            const presetName = appState.currentPreset.name;
            const integrityResult = exportState.integrityResults?.[presetName];

            if (!integrityResult) {
                showToast('è¯·å…ˆé€‰æ‹©å¯¼å‡ºç›®å½•è¿›è¡Œå®Œæ•´æ€§æ£€æŸ¥', 'info');
                return;
            }

            const missingSet = new Set(integrityResult.missing);

            // Initialize hidden set for this preset
            if (!appState.hiddenTasksByPreset[presetId]) {
                appState.hiddenTasksByPreset[presetId] = new Set();
            }

            let hiddenCount = 0;
            appState.tasks.forEach(t => {
                // Hide tasks that are NOT missing (i.e., already exist in directory)
                if (!missingSet.has(t.name)) {
                    appState.hiddenTasksByPreset[presetId].add(t.name);
                    hiddenCount++;
                }
            });

            renderTable();
            updateStatus();
            showToast(`å·²æ¸…ç† ${hiddenCount} ä¸ªä»»åŠ¡`, 'success');
        }

        window.retryTask = (id) => {
            const t = appState.tasks.find(x => x.id == id);
            if (!t) return;

            // Check API Key based on current preset's provider
            const provider = appState.currentPreset.provider;
            if (provider === 'elevenlabs') {
                if (!appState.elevenlabsApiKey) {
                    showToast('è¯·å…ˆè®¾ç½® ElevenLabs API Key', 'error');
                    return;
                }
            } else {
                if (!appState.apiKey) {
                    showToast('è¯·å…ˆè®¾ç½® MiniMax API Key', 'error');
                    return;
                }
            }

            // Reset status for current preset
            const currentPid = appState.currentPreset.id;
            if (!t.results[currentPid]) t.results[currentPid] = { blob: null };
            t.results[currentPid].status = 'pending';
            addToQueue(t, currentPid);
        };

        window.playAudio = (id) => {
            const t = appState.tasks.find(x => x.id == id);
            const currentPid = appState.currentPreset.id;
            const res = t && t.results[currentPid];
            if (res && res.blob) {
                const url = URL.createObjectURL(res.blob);
                const audio = new Audio(url);
                audio.play();
            }
        };

        // --- Selection Logic ---
        function handleRowClick(e, id) {
            // Left Click (0)
            if (e.button === 0) {
                if (e.shiftKey) {
                    // Shift + Left: Add to selection (Multi-select)
                    appState.selectedIds.add(id);
                } else {
                    // Normal Left: Select only this (Clear others)
                    // But if usage wants standard behavior: Ctrl for toggle. 
                    // User asked: "Shift+Left multi-select".
                    appState.selectedIds.clear();
                    appState.selectedIds.add(id);
                }
            }
            // Right Click (2)
            else if (e.button === 2) {
                if (e.shiftKey) {
                    // Shift + Right: Deselect
                    appState.selectedIds.delete(id);
                }
            }
            renderTable();
        }

        function startSelectedGeneration() {
            // Check API Key based on current preset's provider
            const provider = appState.currentPreset.provider;
            if (provider === 'elevenlabs') {
                if (!appState.elevenlabsApiKey) {
                    showToast('è¯·å…ˆè®¾ç½® ElevenLabs API Key', 'error');
                    els.settingsModal.classList.remove('hidden');
                    return;
                }
            } else {
                if (!appState.apiKey) {
                    showToast('è¯·å…ˆè®¾ç½® MiniMax API Key', 'error');
                    els.settingsModal.classList.remove('hidden');
                    return;
                }
            }

            const currentPid = appState.currentPreset.id;

            // Find valid tasks in Selection
            const targets = appState.tasks.filter(t => {
                if (!appState.selectedIds.has(t.id)) return false;
                // Check status in CURRENT preset
                const res = t.results[currentPid];
                if (!res) return true; // Never run
                return res.status === 'pending' || res.status === 'failed' || !res.status;
            });

            if (targets.length === 0) {
                showToast('é€‰ä¸­é¡¹ä¸­æ²¡æœ‰å¾…å¤„ç†çš„ä»»åŠ¡', 'info');
                return;
            }

            showToast(`å¼€å§‹å¤„ç† ${targets.length} ä¸ªä»»åŠ¡...`);
            targets.forEach(t => addToQueue(t, currentPid));
        }

        function addToQueue(task, presetId) {
            // Avoid duplicates
            if (appState.queue.find(q => q.task.id === task.id && q.presetId === presetId)) return;

            // Check processing status
            const res = task.results[presetId];
            if (res && res.status === 'processing') return;

            appState.queue.push({ task, presetId });
            processQueue();
        }

        function processQueue() {
            if (appState.processingCount >= MAX_CONCURRENCY) return;
            if (appState.queue.length === 0) return;

            // Rate Limiting Check
            const now = Date.now();
            const timeSinceLast = now - appState.lastRequestTime;
            if (timeSinceLast < REQUEST_INTERVAL) {
                const delay = REQUEST_INTERVAL - timeSinceLast;
                setTimeout(processQueue, delay);
                return;
            }

            const item = appState.queue.shift();
            const { task, presetId } = item;

            // Initialize or update result object
            if (!task.results[presetId]) {
                task.results[presetId] = {
                    blob: null,
                    text: getDisplayText(task, VOICE_PRESETS.find(p => p.id === presetId)?.lang || 'en')
                };
            }
            task.results[presetId].status = 'processing';

            appState.processingCount++;
            appState.lastRequestTime = Date.now(); // Update timestamp
            renderTable();

            // Call API
            generateAudio(task, presetId).finally(() => {
                appState.processingCount--;
                processQueue();
            });
        }

        // --- API Integration ---

        async function generateAudio(task, presetId) {
            const preset = VOICE_PRESETS.find(p => p.id === presetId) || appState.currentPreset;

            // Route to appropriate provider
            if (preset.provider === 'elevenlabs') {
                return generateAudioElevenLabs(task, preset);
            } else {
                return generateAudioMiniMax(task, preset);
            }
        }

        // --- MiniMax TTS ---
        async function generateAudioMiniMax(task, preset) {
            const resObject = task.results[preset.id];
            const config = preset.config || {};

            const payload = {
                "model": appState.apiModel,
                "text": (resObject.text || getDisplayText(task, preset.lang)) + (preset.lang === 'zh' ? 'ã€‚' : ''),
                "stream": false,
                "voice_setting": {
                    "voice_id": config.voiceId,
                    "speed": config.speed || 1,
                    "vol": config.vol || 1,
                    "pitch": config.pitch || 0,
                    "emotion": config.emotion || "neutral"
                },
                "audio_setting": {
                    "sample_rate": 44100,
                    "bitrate": 128000,
                    "format": "wav",
                    "channel": 2
                }
            };

            try {
                const url = new URL(appState.apiEndpoint);
                if (appState.groupId) {
                    url.searchParams.append("GroupId", appState.groupId);
                }

                const response = await fetch(url.toString(), {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${appState.apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const err = await response.text();
                    throw new Error(`MiniMax API Error: ${response.status} - ${err}`);
                }

                const data = await response.json();

                if (data.base_resp && data.base_resp.status_code !== 0) {
                    throw new Error(`MiniMax API Error: ${data.base_resp.status_msg}`);
                }

                if (data.data && data.data.audio) {
                    const hex = data.data.audio;
                    const buffer = new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                    const blob = new Blob([buffer], { type: 'audio/wav' });

                    resObject.blob = blob;
                    resObject.status = 'completed';
                } else {
                    throw new Error("Invalid MiniMax API Response");
                }

            } catch (e) {
                console.error(e);
                resObject.status = 'failed';
                showToast(`Task ${task.name} Failed: ${e.message}`, 'error');
            } finally {
                renderTable();
            }
        }

        // --- ElevenLabs TTS ---
        async function generateAudioElevenLabs(task, preset) {
            const resObject = task.results[preset.id];
            const config = preset.config || {};
            let text = resObject.text || getDisplayText(task, preset.lang);

            if (!appState.elevenlabsApiKey) {
                resObject.status = 'failed';
                showToast(`è¯·å…ˆè®¾ç½® ElevenLabs API Key`, 'error');
                renderTable();
                return;
            }

            // Apply Audio Tags only if using V3 model
            const supportsAudioTags = appState.elevenlabsModel === 'eleven_v3';
            if (supportsAudioTags && config.textPrompt) {
                text = config.textPrompt + " " + text;
            }

            try {
                // Use mp3_44100_128 format (available for all tiers)
                // pcm_44100 requires Pro tier
                const response = await fetch(
                    `https://api.elevenlabs.io/v1/text-to-speech/${config.voiceId}/stream?output_format=mp3_44100_128`,
                    {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'xi-api-key': appState.elevenlabsApiKey
                        },
                        body: JSON.stringify({
                            text: text,
                            model_id: appState.elevenlabsModel,
                            voice_settings: (() => {
                                const settings = {
                                    stability: config.stability ?? 0.5,
                                    similarity_boost: config.similarity_boost ?? 1,
                                    use_speaker_boost: config.use_speaker_boost ?? false
                                };
                                // style parameter only supported by v3 and multilingual_v2
                                const supportsStyle = ['eleven_v3', 'eleven_multilingual_v2'].includes(appState.elevenlabsModel);
                                if (supportsStyle && config.style !== undefined) {
                                    settings.style = config.style;
                                }
                                return settings;
                            })()
                        })
                    }
                );

                if (!response.ok) {
                    const err = await response.text();
                    throw new Error(`ElevenLabs API Error: ${response.status} - ${err}`);
                }

                // Get MP3 blob directly
                const mp3Blob = await response.blob();
                resObject.blob = new Blob([mp3Blob], { type: 'audio/mpeg' });
                resObject.status = 'completed';

            } catch (e) {
                console.error(e);
                resObject.status = 'failed';
                showToast(`Task ${task.name} Failed: ${e.message}`, 'error');
            } finally {
                renderTable();
            }
        }

        // --- PCM to WAV Conversion ---
        function pcmToWav(pcmBuffer, sampleRate, numChannels, bitsPerSample) {
            const dataLength = pcmBuffer.byteLength;
            const buffer = new ArrayBuffer(44 + dataLength);
            const view = new DataView(buffer);

            // Helper to write string
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };

            // WAV Header
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true); // Subchunk1Size (PCM)
            view.setUint16(20, 1, true);  // AudioFormat (PCM = 1)
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * bitsPerSample / 8, true); // ByteRate
            view.setUint16(32, numChannels * bitsPerSample / 8, true); // BlockAlign
            view.setUint16(34, bitsPerSample, true);
            writeString(36, 'data');
            view.setUint32(40, dataLength, true);

            // Copy PCM data
            new Uint8Array(buffer, 44).set(new Uint8Array(pcmBuffer));

            return new Blob([buffer], { type: 'audio/wav' });
        }

        // --- Export ---

        function openExportModal() {
            // Preserve directory handle if already selected
            if (exportState.directoryHandle) {
                // Restore cached state
                els.exportDirLabel.textContent = `ğŸ“‚ ${exportState.directoryName}`;
                els.btnExportCurrentPreset.disabled = false;
                els.btnExportAllPresets.disabled = false;
                updateExportUnnecessaryButton();
                // Show cached integrity results if available
                renderIntegrityResults();
            } else {
                // Fresh state
                els.exportDirLabel.textContent = 'ğŸ“ ç‚¹å‡»é€‰æ‹©å¯¼å‡ºç›®å½•';
                els.btnExportCurrentPreset.disabled = true;
                els.btnExportAllPresets.disabled = true;
                els.btnExportUnnecessary.disabled = true;
                els.integrityCheckResults.style.display = 'none';
            }
            els.exportModal.classList.remove('hidden');
        }

        function closeExportModal() {
            els.exportModal.classList.add('hidden');
        }

        async function selectExportDirectory() {
            try {
                const handle = await window.showDirectoryPicker();
                exportState.directoryHandle = handle;
                exportState.directoryName = handle.name;
                els.exportDirLabel.textContent = `ğŸ“‚ ${handle.name}`;
                els.btnExportCurrentPreset.disabled = false;
                els.btnExportAllPresets.disabled = false;
                updateExportUnnecessaryButton();

                // Auto-trigger integrity check
                await checkAssetIntegrity();
            } catch (e) {
                if (e.name !== 'AbortError') {
                    showToast('é€‰æ‹©ç›®å½•å¤±è´¥', 'error');
                }
            }
        }

        async function checkAssetIntegrity() {
            if (!exportState.directoryHandle || appState.tasks.length === 0) {
                exportState.integrityResults = null;
                renderIntegrityResults();
                return;
            }

            // Generate cache key based on task names
            const taskHash = appState.tasks.map(t => t.name).sort().join(',');
            const langFilter = appState.currentLangFilter;
            const dirName = exportState.directoryHandle.name;

            // Check cache - skip re-check if unchanged
            if (exportState.integrityResults &&
                exportState.cachedTaskHash === taskHash &&
                exportState.cachedDirName === dirName &&
                exportState.cachedLangFilter === langFilter) {
                renderIntegrityResults();
                return;
            }

            const results = {};

            // Only check presets with the same language as imported file
            const presetsToCheck = langFilter
                ? VOICE_PRESETS.filter(p => p.lang === langFilter)
                : VOICE_PRESETS;

            for (const preset of presetsToCheck) {
                try {
                    const presetDir = await exportState.directoryHandle.getDirectoryHandle(preset.name);
                    const existingFiles = new Set();

                    // Collect WAV files in directory
                    for await (const [name, handle] of presetDir.entries()) {
                        if (handle.kind === 'file' && name.toLowerCase().endsWith('.wav')) {
                            existingFiles.add(name.replace(/\.wav$/i, ''));
                        }
                    }

                    // Compare with task list
                    const requiredFiles = new Set(appState.tasks.map(t => t.name));
                    const missing = [...requiredFiles].filter(f => !existingFiles.has(f));
                    const extra = [...existingFiles].filter(f => !requiredFiles.has(f));

                    results[preset.name] = { missing, extra, total: requiredFiles.size, exists: existingFiles.size };

                } catch (e) {
                    // Directory doesn't exist
                    results[preset.name] = {
                        missing: appState.tasks.map(t => t.name),
                        extra: [],
                        total: appState.tasks.length,
                        exists: 0,
                        notFound: true
                    };
                }
            }

            exportState.integrityResults = results;
            // Update cache keys
            exportState.cachedTaskHash = taskHash;
            exportState.cachedDirName = dirName;
            exportState.cachedLangFilter = langFilter;
            renderIntegrityResults();
            updateStatus(); // Update cleanup button state
            updateExportUnnecessaryButton(); // Update export unnecessary button state
        }

        function renderIntegrityResults() {
            if (!exportState.integrityResults) {
                els.integrityCheckResults.style.display = 'none';
                return;
            }

            els.integrityCheckResults.style.display = 'block';

            const currentPresetName = appState.currentPreset?.name;

            let html = '';
            for (const [presetName, result] of Object.entries(exportState.integrityResults)) {
                const isComplete = result.missing.length === 0 && result.extra.length === 0;
                const status = result.notFound ? 'â“' : (isComplete ? 'âœ…' : 'âš ï¸');
                const isSelected = presetName === currentPresetName;
                const borderStyle = isSelected ? 'border: 2px solid #0078d4;' : 'border: 1px solid transparent;';
                const bgStyle = isSelected ? 'background: #1a3a5a;' : 'background: #1a1a1a;';

                html += `<div style="margin-bottom: 8px; padding: 8px; ${bgStyle} ${borderStyle} border-radius: 4px; transition: all 0.2s;">
                    <strong>${status} ${presetName}</strong>: 
                    ç¼ºå¤± <span style="color: ${result.missing.length > 0 ? '#ff6b6b' : '#4caf50'};">${result.missing.length}</span> | 
                    å¤šä½™ <span style="color: ${result.extra.length > 0 ? '#ffa726' : '#4caf50'};">${result.extra.length}</span> | 
                    å·²æœ‰ ${result.exists}/${result.total}
                    ${result.notFound ? ' <span style="color: #888;">(ç›®å½•ä¸å­˜åœ¨)</span>' : ''}
                </div>`;
            }

            els.integrityStats.innerHTML = html;
        }

        // Check if current preset has unnecessary assets
        function updateExportUnnecessaryButton() {
            if (!exportState.integrityResults || !appState.currentPreset) {
                els.btnExportUnnecessary.disabled = true;
                return;
            }
            const result = exportState.integrityResults[appState.currentPreset.name];
            els.btnExportUnnecessary.disabled = !result || result.extra.length === 0;
        }

        // Export unnecessary assets list as JSON
        async function exportUnnecessaryAssets() {
            if (!exportState.directoryHandle || !appState.currentPreset) {
                showToast('è¯·å…ˆé€‰æ‹©å¯¼å‡ºç›®å½•', 'error');
                return;
            }

            const presetName = appState.currentPreset.name;
            const result = exportState.integrityResults?.[presetName];

            if (!result || result.extra.length === 0) {
                showToast('å½“å‰é¢„è®¾æ²¡æœ‰å¤šä½™èµ„äº§', 'info');
                return;
            }

            try {
                const presetDir = await exportState.directoryHandle.getDirectoryHandle(presetName, { create: true });
                const fileName = `${presetName}_unnecessary.json`;
                const fileHandle = await presetDir.getFileHandle(fileName, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(JSON.stringify(result.extra, null, 2));
                await writable.close();

                showToast(`å·²å¯¼å‡º ${result.extra.length} ä¸ªå¤šä½™èµ„äº§åˆ° ${fileName}`, 'info');
            } catch (e) {
                console.error(e);
                showToast('å¯¼å‡ºå¤±è´¥: ' + e.message, 'error');
            }
        }

        async function executeExport(mode) {
            if (!exportState.directoryHandle) {
                showToast('è¯·å…ˆé€‰æ‹©å¯¼å‡ºç›®å½•', 'error');
                return;
            }

            closeExportModal();

            const presetsToExport = mode === 'all'
                ? VOICE_PRESETS
                : [appState.currentPreset];

            let totalSaved = 0;
            let totalItems = 0;

            for (const preset of presetsToExport) {
                const presetId = preset.id;
                const presetName = preset.name;
                const validItems = [];
                const uncalibratedItems = [];

                appState.tasks.forEach(t => {
                    const res = t.results[presetId];
                    if (res && res.blob) {
                        if (res.status === 'edited') {
                            validItems.push({ name: t.name, blob: res.blob, task: t, presetId, status: 'edited' });
                        } else if (res.status === 'completed') {
                            validItems.push({ name: t.name, blob: res.blob, task: t, presetId, status: 'completed' });
                            uncalibratedItems.push(`${t.name}-${presetName}`);
                        }
                    }
                });

                if (validItems.length === 0) continue;

                // Warning for uncalibrated items (only for single preset mode)
                if (mode === 'current' && uncalibratedItems.length > 0) {
                    const msg = "è¿˜æœ‰ä»¥ä¸‹éŸ³é¢‘æœªæ ¡å‡† (ä»…å·²å®Œæˆï¼Œæœªäººå·¥ç¼–è¾‘):\n\n" +
                        uncalibratedItems.slice(0, 10).join('\n') +
                        (uncalibratedItems.length > 10 ? `\n...ç­‰ ${uncalibratedItems.length} ä¸ª` : "") +
                        "\n\næ˜¯å¦ç»§ç»­å¯¼å‡º?";
                    if (!await showConfirmModal(msg)) {
                        return; // Abort
                    }
                }

                try {
                    // Create/Get Subfolder for Preset Name
                    const presetDir = await exportState.directoryHandle.getDirectoryHandle(presetName, { create: true });

                    showToast(`æ­£åœ¨å¯¼å‡º ${presetName}: ${validItems.length} ä¸ªæ–‡ä»¶...`);

                    // Write Files
                    for (const item of validItems) {
                        try {
                            const fileHandle = await presetDir.getFileHandle(`${item.name}.wav`, { create: true });
                            const writable = await fileHandle.createWritable();
                            await writable.write(item.blob);
                            await writable.close();

                            // Mark as exported
                            item.task.results[presetId].exported = true;
                            totalSaved++;
                        } catch (e) {
                            console.error(`Failed to write ${item.name}`, e);
                        }
                    }

                    totalItems += validItems.length;

                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.error(err);
                        showToast(`å¯¼å‡º ${presetName} å¤±è´¥: ${err.message}`, 'error');
                    }
                }
            }

            if (totalItems > 0) {
                showToast(`âœ… å¯¼å‡ºå®Œæˆ: æˆåŠŸ ${totalSaved} / æ€»è®¡ ${totalItems}`);
            } else {
                showToast('æ²¡æœ‰å¯å¯¼å‡ºçš„éŸ³é¢‘', 'info');
            }
        }







        // Run
        init();

    </script>
    <script src="https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.min.js"></script>
    <script>
        // --- Audio Editor Logic ---

        // --- Audio Editor Logic ---

        // Reference Audios stored per preset (in memory)
        const referenceAudios = {}; // { [presetId]: Blob }

        let editorState = {
            taskId: null,
            presetId: null,
            originalBlob: null,
            wavesurfer: null,
            audioContext: null,
            sourceNode: null,
            gainNode: null,
            // Stable Filter Nodes
            hpNode: null,
            lpNode: null,
            distNode: null,
            isPlaying: false,
            // Reference Audio
            refWavesurfer: null,
            refBlob: null,
            // Regions
            regions: null,
            activeRegion: null
        };

        const editorEls = {
            modal: document.getElementById('audioEditorModal'),
            fileName: document.getElementById('editorFileName'),
            waveform: document.getElementById('waveform'),
            sliderVol: document.getElementById('sliderVol'),
            sliderRate: document.getElementById('sliderRate'),
            sliderPitch: document.getElementById('sliderPitch'),
            checkRadio: document.getElementById('checkRadio'),
            valVol: document.getElementById('valVol'),
            valRate: document.getElementById('valRate'),
            valPitch: document.getElementById('valPitch'),
            btnPlay: document.getElementById('btnEditorPlay'),
            btnReset: document.getElementById('btnEditorReset'),
            btnSave: document.getElementById('btnEditorSave'),
            btnCancel: document.getElementById('btnEditorCancel'),
            btnDeleteRegion: document.getElementById('btnDeleteRegion'),
            // Reference Audio
            waveformRef: document.getElementById('waveformRef'),
            refFileInput: document.getElementById('refFileInput'),
            btnClearRef: document.getElementById('btnClearRef'),
            // New Controls
            sliderHighpass: document.getElementById('sliderHighpass'),
            sliderLowpass: document.getElementById('sliderLowpass'),
            sliderDistortion: document.getElementById('sliderDistortion'),
            valHPF: document.getElementById('valHPF'),
            valLPF: document.getElementById('valLPF'),
            valDist: document.getElementById('valDist'),
            btnPrevTask: document.getElementById('btnPrevTask'),
            btnNextTask: document.getElementById('btnNextTask'),
            exportFormat: document.getElementById('editorExportFormat'),
            checkAutoSaveParams: document.getElementById('checkAutoSaveParams')
        };

        function initAudioEditor() {
            // Event Listeners
            editorEls.btnPlay.onclick = toggleEditorPlay;
            editorEls.btnReset.onclick = resetEditorParams;
            editorEls.btnSave.onclick = saveAudioEditor;
            editorEls.btnCancel.onclick = closeEditor;
            editorEls.btnDeleteRegion.onclick = deleteSelectedRegion;

            editorEls.sliderVol.oninput = updateEditorParams;
            editorEls.sliderRate.oninput = updateEditorParams;
            editorEls.sliderPitch.oninput = updateEditorParams;
            editorEls.checkRadio.onchange = updateEditorParams;

            // New FX Listeners
            editorEls.sliderHighpass.oninput = updateEditorParams;
            editorEls.sliderLowpass.oninput = updateEditorParams;
            editorEls.sliderDistortion.oninput = updateEditorParams;

            // Navigation Listeners
            editorEls.btnPrevTask.onclick = () => navigateTask(-1);
            editorEls.btnNextTask.onclick = () => navigateTask(1);

            // Auto-save params checkbox listener
            editorEls.checkAutoSaveParams.onchange = (e) => {
                if (e.target.checked) {
                    saveCurrentEditorParams();
                    showToast('å·²ä¿å­˜å½“å‰å‚æ•°ï¼Œå°†è‡ªåŠ¨åº”ç”¨åˆ°æœªç¼–è¾‘ä»»åŠ¡', 'info');
                }
            };

            // Close on overlay click
            editorEls.modal.onclick = (e) => {
                if (e.target === editorEls.modal) closeEditor();
            };

            // Reference Audio Listeners
            const refDropzone = document.getElementById('refDropzone');
            refDropzone.onclick = () => editorEls.refFileInput.click();
            refDropzone.ondragover = (e) => e.preventDefault();
            refDropzone.ondragenter = (e) => {
                e.preventDefault();
                refDropzone.style.borderColor = '#ff9800';
                refDropzone.style.background = '#333';
            };
            refDropzone.ondragleave = (e) => {
                e.preventDefault();
                refDropzone.style.borderColor = '#555';
                refDropzone.style.background = '#1a1a1a';
            };
            refDropzone.ondrop = handleRefDrop;

            editorEls.refFileInput.onchange = handleRefFileSelect;
            editorEls.btnClearRef.onclick = () => {
                const pid = editorState.presetId;
                if (pid) delete referenceAudios[pid];
                loadReferenceAudio(pid); // reload to clear
            };

            // Init Wavesurfer if not exists
        }

        // Called manually after main init
        initAudioEditor();

        // Helper to load WaveSurfer dynamically
        async function ensureWaveSurferLoaded() {
            if (window.WaveSurfer && window.WaveSurfer.Regions) return;

            try {
                const [wsModule, rgModule] = await Promise.all([
                    import('https://cdn.jsdelivr.net/npm/wavesurfer.js@7/dist/wavesurfer.esm.js'),
                    import('https://cdn.jsdelivr.net/npm/wavesurfer.js@7/dist/plugins/regions.esm.js')
                ]);

                window.WaveSurfer = wsModule.default;
                // Attach Regions to WaveSurfer to match expected UMD structure
                window.WaveSurfer.Regions = rgModule.default;
            } catch (error) {
                console.error("Failed to load WaveSurfer:", error);
                showToast("æ— æ³•åŠ è½½éŸ³é¢‘ç»„ä»¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ", "error");
                throw error;
            }
        }

        async function openAudioEditor(taskId) {
            await ensureWaveSurferLoaded();

            const task = appState.tasks.find(t => t.id == taskId);
            const currentPid = appState.currentPreset.id;
            const res = task?.results[currentPid];

            if (!res || !res.blob) {
                showToast("æ— æ³•åŠ è½½éŸ³é¢‘", "error");
                return;
            }

            editorState.taskId = taskId;
            editorState.presetId = currentPid;
            editorState.originalBlob = res.blob;

            editorEls.fileName.textContent = `${task.name} (${appState.currentPreset.name})`;
            editorEls.modal.classList.remove('hidden');

            // Init Wavesurfer if not exists
            // Init Wavesurfer if not exists
            if (!editorState.wavesurfer) {
                try {
                    const RegionsPlugin = WaveSurfer.Regions || window.RegionsPlugin;
                    if (!RegionsPlugin) {
                        throw new Error("Regions plugin not loaded");
                    }

                    // Create Regions plugin
                    editorState.regions = RegionsPlugin.create();

                    // Check status for color
                    const isEdited = res.status === 'edited';
                    const waveColor = isEdited ? '#4caf50' : '#0078d4';
                    const progressColor = isEdited ? '#81c784' : '#55aaff';

                    editorState.wavesurfer = WaveSurfer.create({
                        container: '#waveform',
                        waveColor: waveColor,
                        progressColor: progressColor,
                        cursorColor: '#ffffff',
                        height: 150,
                        barWidth: 2,
                        hideScrollbar: true,
                        backend: 'MediaElement',
                        plugins: [editorState.regions]
                    });

                    // Region events
                    editorState.regions.enableDragSelection({
                        color: 'rgba(255, 107, 107, 0.3)'
                    });

                    editorState.regions.on('region-created', (region) => {
                        // Remove previous region if exists (only allow one)
                        if (editorState.activeRegion && editorState.activeRegion !== region) {
                            editorState.activeRegion.remove();
                        }
                        editorState.activeRegion = region;
                        editorEls.btnDeleteRegion.disabled = false;
                    });

                    editorState.regions.on('region-updated', (region) => {
                        editorState.activeRegion = region;
                        editorEls.btnDeleteRegion.disabled = false;
                    });
                } catch (e) {
                    console.error("Wavesurfer Init Error:", e);
                    const debugInfo = window.WaveSurfer ? Object.keys(window.WaveSurfer).join(',') : "WaveSurfer undefined";
                    showToast(`æ³¢å½¢åˆå§‹åŒ–å¤±è´¥: ${e.message} (Keys: ${debugInfo})`, "error");
                    return;
                }

                editorState.wavesurfer.on('finish', () => {
                    editorEls.btnPlay.textContent = "â–¶ é¢„è§ˆ";
                    editorState.isPlaying = false;
                    // Chain reference audio playback
                    if (editorState.refWavesurfer && editorState.refBlob) {
                        editorState.refWavesurfer.play();
                    }
                });

                editorState.wavesurfer.on('play', () => {
                    editorEls.btnPlay.textContent = "â¸ æš‚åœ";
                    editorState.isPlaying = true;
                });

                editorState.wavesurfer.on('pause', () => {
                    editorEls.btnPlay.textContent = "â–¶ é¢„è§ˆ";
                    editorState.isPlaying = false;
                });

                // Init Web Audio Graph ONCE when ready
                editorState.wavesurfer.on('ready', initWebAudioGraph);
            }

            // Apply color based on current status (Green if edited, Blue if original)
            const isEdited = res.status === 'edited';
            editorState.wavesurfer.setOptions({
                waveColor: isEdited ? '#4caf50' : '#0078d4',
                progressColor: isEdited ? '#81c784' : '#55aaff'
            });

            // Load Blob
            const url = URL.createObjectURL(res.blob);
            await editorState.wavesurfer.load(url);

            // Load Reference Audio for this preset if exists
            loadReferenceAudio(currentPid);

            // Auto-apply params logic
            const autoSaveEnabled = editorEls.checkAutoSaveParams.checked;
            const taskIsEdited = res.status === 'edited';

            if (autoSaveEnabled && appState.savedEditorParams) {
                if (taskIsEdited) {
                    // Already edited task - reset to defaults
                    resetEditorParams();
                } else {
                    // Completed but unedited - apply saved params
                    applyEditorParams(appState.savedEditorParams);
                }
            } else {
                // Auto-save disabled or no saved params - always reset
                resetEditorParams();
            }
        }

        // Reference Audio Functions
        function loadReferenceAudio(presetId) {
            const refBlob = referenceAudios[presetId];
            editorState.refBlob = refBlob || null;

            const refDropzone = document.getElementById('refDropzone');

            if (refBlob) {
                // Show waveform, hide dropzone
                refDropzone.style.display = 'none';
                editorEls.waveformRef.style.display = 'block';
                editorEls.btnClearRef.style.display = 'inline-block';

                // Init or load ref wavesurfer
                if (!editorState.refWavesurfer) {
                    editorState.refWavesurfer = WaveSurfer.create({
                        container: '#waveformRef',
                        waveColor: '#ff9800',
                        progressColor: '#ffb74d',
                        cursorColor: '#ff9800',
                        height: 90,
                        barWidth: 2,
                        hideScrollbar: true,
                        cursorWidth: 0 // Hide cursor for reference
                    });
                }
                const refUrl = URL.createObjectURL(refBlob);
                editorState.refWavesurfer.load(refUrl);
            } else {
                // Reset UI - show dropzone, hide waveform
                refDropzone.style.display = 'flex';
                editorEls.waveformRef.style.display = 'none';
                editorEls.btnClearRef.style.display = 'none';
                if (editorState.refWavesurfer) {
                    editorState.refWavesurfer.empty();
                }
            }
        }

        function handleRefFileSelect(e) {
            const file = e.target.files[0];
            if (file) importReferenceAudio(file);
            e.target.value = ''; // Reset for re-import
        }

        function handleRefDrop(e) {
            e.preventDefault();
            const refDropzone = document.getElementById('refDropzone');
            refDropzone.style.borderColor = '#555';
            refDropzone.style.background = '#1a1a1a';

            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('audio/')) {
                importReferenceAudio(file);
            } else {
                showToast("è¯·æ‹–æ”¾éŸ³é¢‘æ–‡ä»¶", "error");
            }
        }

        function importReferenceAudio(file) {
            const presetId = editorState.presetId;
            const blob = file;
            referenceAudios[presetId] = blob;
            loadReferenceAudio(presetId);
            showToast("å‚è€ƒéŸ³é¢‘å·²å¯¼å…¥", "success");
        }

        function clearReferenceAudio() {
            const presetId = editorState.presetId;
            delete referenceAudios[presetId];
            editorState.refBlob = null;

            const refDropzone = document.getElementById('refDropzone');
            refDropzone.style.display = 'flex';
            editorEls.waveformRef.style.display = 'none';
            editorEls.btnClearRef.style.display = 'none';

            if (editorState.refWavesurfer) {
                editorState.refWavesurfer.empty();
            }
            showToast("å‚è€ƒéŸ³é¢‘å·²æ¸…é™¤", "info");
        }

        async function deleteSelectedRegion() {
            if (!editorState.activeRegion) {
                showToast("è¯·å…ˆé€‰ä¸­è¦åˆ é™¤çš„åŒºåŸŸ", "error");
                return;
            }

            const region = editorState.activeRegion;
            const startTime = region.start;
            const endTime = region.end;

            try {
                // Decode current audio
                const arrayBuffer = await editorState.originalBlob.arrayBuffer();
                const tempCtx = new (window.AudioContext || window.webkitAudioContext)();
                const audioBuffer = await tempCtx.decodeAudioData(arrayBuffer);

                const sampleRate = audioBuffer.sampleRate;
                const numChannels = audioBuffer.numberOfChannels;

                const startSample = Math.floor(startTime * sampleRate);
                const endSample = Math.floor(endTime * sampleRate);
                const deletionLength = endSample - startSample;

                if (deletionLength <= 0) {
                    showToast("é€‰åŒºæ— æ•ˆ", "error");
                    return;
                }

                const newLength = audioBuffer.length - deletionLength;
                const newBuffer = tempCtx.createBuffer(numChannels, newLength, sampleRate);

                // Crossfade settings (10ms)
                const fadeSamples = Math.floor(0.01 * sampleRate); // 10ms

                for (let ch = 0; ch < numChannels; ch++) {
                    const oldData = audioBuffer.getChannelData(ch);
                    const newData = newBuffer.getChannelData(ch);

                    // Copy data before the cut
                    for (let i = 0; i < startSample; i++) {
                        newData[i] = oldData[i];
                    }

                    // Copy data after the cut
                    for (let i = 0; i < audioBuffer.length - endSample; i++) {
                        newData[startSample + i] = oldData[endSample + i];
                    }

                    // Apply crossfade around the cut point
                    // Fade out before cut (last fadeSamples of kept part)
                    const fadeOutStart = Math.max(0, startSample - fadeSamples);
                    for (let i = fadeOutStart; i < startSample; i++) {
                        const fadePos = (i - fadeOutStart) / fadeSamples;
                        newData[i] *= (1 - fadePos); // Linear fade out
                    }

                    // Fade in after cut (first fadeSamples of remaining part)
                    const fadeInEnd = Math.min(newLength, startSample + fadeSamples);
                    for (let i = startSample; i < fadeInEnd; i++) {
                        const fadePos = (i - startSample) / fadeSamples;
                        newData[i] *= fadePos; // Linear fade in
                    }
                }

                // Convert to WAV blob
                const newBlob = bufferToWave(newBuffer, 0, newBuffer.length);

                // Update state
                editorState.originalBlob = newBlob;

                // Clear region
                region.remove();
                editorState.activeRegion = null;
                editorEls.btnDeleteRegion.disabled = true;

                // Reload waveform
                const url = URL.createObjectURL(newBlob);
                await editorState.wavesurfer.load(url);

                tempCtx.close();
                showToast("é€‰åŒºå·²åˆ é™¤", "success");

            } catch (e) {
                console.error("Delete region error:", e);
                showToast("åˆ é™¤å¤±è´¥: " + e.message, "error");
            }
        }

        function initWebAudioGraph() {
            if (editorState.audioContext) return; // Already init

            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                const ctx = new AudioContext();
                editorState.audioContext = ctx;

                const media = editorState.wavesurfer.getMediaElement();
                // Important: Unlock audio on user interaction if needed, but we are inside a click handler chain usually.

                // 1. Source
                editorState.sourceNode = ctx.createMediaElementSource(media);

                // 2. Create Filters (persistent)
                editorState.hpNode = ctx.createBiquadFilter();
                editorState.hpNode.type = 'highpass';
                editorState.hpNode.frequency.value = 300;

                editorState.lpNode = ctx.createBiquadFilter();
                editorState.lpNode.type = 'lowpass';
                editorState.lpNode.frequency.value = 3500;

                editorState.distNode = ctx.createWaveShaper();
                editorState.distNode.curve = makeDistortionCurve(50);
                editorState.distNode.oversample = '4x';

                // 3. Gain (Volume)
                editorState.gainNode = ctx.createGain();

                // 4. Connect Initial Graph (Bypassed)
                // Source -> Gain -> Destination
                editorState.sourceNode.connect(editorState.gainNode);
                editorState.gainNode.connect(ctx.destination);

                // Ensure pure media element volume is 1 (we control gainNode instead)
                editorState.wavesurfer.setVolume(1);

            } catch (e) {
                console.error("Web Audio Init Failed:", e);
                showToast("éŸ³é¢‘å¼•æ“åˆå§‹åŒ–å¤±è´¥", "error");
            }
        }

        function closeEditor() {
            editorEls.modal.classList.add('hidden');
            if (editorState.wavesurfer) {
                editorState.wavesurfer.pause();
            }
            if (editorState.audioContext && editorState.audioContext.state !== 'closed') {
                editorState.audioContext.suspend();
            }
        }

        function resetEditorParams() {
            editorEls.sliderVol.value = 0;
            editorEls.sliderRate.value = 1.0;
            editorEls.sliderPitch.value = 0;
            editorEls.sliderHighpass.value = 300;
            editorEls.sliderLowpass.value = 3500;
            editorEls.sliderDistortion.value = 50;
            editorEls.checkRadio.checked = false;
            updateEditorParams();
        }

        // Save current editor params for auto-apply feature
        function saveCurrentEditorParams() {
            appState.savedEditorParams = {
                vol: parseFloat(editorEls.sliderVol.value),
                rate: parseFloat(editorEls.sliderRate.value),
                pitch: parseFloat(editorEls.sliderPitch.value),
                hpf: parseFloat(editorEls.sliderHighpass.value),
                lpf: parseFloat(editorEls.sliderLowpass.value),
                dist: parseFloat(editorEls.sliderDistortion.value),
                radioEnabled: editorEls.checkRadio.checked
            };
        }

        // Apply saved editor params
        function applyEditorParams(params) {
            if (!params) return;
            editorEls.sliderVol.value = params.vol;
            editorEls.sliderRate.value = params.rate;
            editorEls.sliderPitch.value = params.pitch;
            editorEls.sliderHighpass.value = params.hpf;
            editorEls.sliderLowpass.value = params.lpf;
            editorEls.sliderDistortion.value = params.dist;
            editorEls.checkRadio.checked = params.radioEnabled;
            updateEditorParams();
        }

        function updateEditorParams() {
            // Update UI Labels
            editorEls.valVol.textContent = editorEls.sliderVol.value;
            editorEls.valRate.textContent = editorEls.sliderRate.value;
            editorEls.valPitch.textContent = editorEls.sliderPitch.value;

            if (!editorState.wavesurfer || !editorState.audioContext) return;

            // 1. Volume (GainNode)
            // dB to linear gain: 10 ^ (dB / 20)
            const db = parseFloat(editorEls.sliderVol.value);
            const gain = Math.pow(10, db / 20);
            editorState.gainNode.gain.cancelScheduledValues(0);
            editorState.gainNode.gain.setValueAtTime(gain, editorState.audioContext.currentTime);
            // Update visual waveform height based on gain (approximate visual feedback)
            if (editorState.wavesurfer) {
                // Ensure at least some visibility, clamp max scaling to avoid distortion
                const visualScale = Math.min(Math.max(gain, 0.1), 3.0);
                editorState.wavesurfer.setOptions({ barHeight: visualScale });
            }

            // 2. Playback Rate
            const rate = parseFloat(editorEls.sliderRate.value);
            editorState.wavesurfer.setPlaybackRate(rate);

            // 3. Pitch (preserves duration if browser supports, usually works with setPlaybackRate(1) + detune, but here we likely coupled them.
            // Actually wavesurfer V7 preserves pitch by default if using MediaElement?
            // Wait, MediaElement 'preservesPitch' property.
            // If we want independent pitch shift, we need Detune on bufferSource?
            // But we are using MediaElement backend.
            // HTMLMediaElement has 'preservesPitch' (true by default) and 'playbackRate'.
            // Changing playbackRate changes speed AND pitch if preservesPitch=false.
            // With preservesPitch=true (default), it changes speed but keeps pitch.
            // Our sliderPitch logic needs to be verified.
            // Current code likely wasn't actually checking sliderPitch for real-time.
            // Let's implement Detune if we can, or just use playbackRate for now if that's what we have.
            // Wait, if backend is MediaElement, we can't easily detune without changing speed unless we use a PitchShifter node which we don't have.
            // However, the user asked for Pitch slider.
            // The previous logic for pitch was likely effectively doing nothing or using preservePitch.
            // Let's look at how we use it. We export using OfflineAudioContext.
            // In Offline context (buffer based), we CAN use 'detune'.
            // For preview (MediaElement), we might be limited.
            // But let's focus on the routing update first.

            // New: Update FX params
            const hpf = parseInt(editorEls.sliderHighpass.value);
            const lpf = parseInt(editorEls.sliderLowpass.value);
            const dist = parseInt(editorEls.sliderDistortion.value);

            editorEls.valHPF.textContent = hpf;
            editorEls.valLPF.textContent = lpf;
            editorEls.valDist.textContent = dist;

            if (editorState.hpNode) editorState.hpNode.frequency.value = hpf;
            if (editorState.lpNode) editorState.lpNode.frequency.value = lpf;
            if (editorState.distNode) editorState.distNode.curve = makeDistortionCurve(dist);

            // Routing
            const useRadio = editorEls.checkRadio.checked;
            updateGraphRouting(useRadio);

            // UI Enabler
            const fxControls = document.getElementById('radioFxControls');
            if (fxControls) {
                fxControls.style.opacity = useRadio ? '1' : '0.5';
                fxControls.style.pointerEvents = useRadio ? 'auto' : 'none';
            }
            // Resume context if needed
            if (editorState.audioContext.state === 'suspended') {
                editorState.audioContext.resume();
            }
        }

        function updateGraphRouting(useRadio) {
            if (!editorState.sourceNode) return;
            const ctx = editorState.audioContext;

            // Disconnect everything
            try { editorState.sourceNode.disconnect(); } catch (e) { }
            try { editorState.hpNode.disconnect(); } catch (e) { }
            try { editorState.distNode.disconnect(); } catch (e) { }
            try { editorState.lpNode.disconnect(); } catch (e) { }
            try { editorState.gainNode.disconnect(); } catch (e) { }

            // Reconnect
            if (useRadio) {
                // Chain: Source -> HP -> Distortion -> LP -> Gain -> Dest
                editorState.sourceNode.connect(editorState.hpNode);
                editorState.hpNode.connect(editorState.distNode);
                editorState.distNode.connect(editorState.lpNode);
                editorState.lpNode.connect(editorState.gainNode);
            } else {
                // Chain: Source -> Gain -> Dest
                editorState.sourceNode.connect(editorState.gainNode);
            }

            editorState.gainNode.connect(ctx.destination);
        }

        // Navigation Logic
        function navigateTask(direction) {
            if (!editorState.taskId) return;

            const tasks = appState.tasks;
            const startIndex = tasks.findIndex(t => t.id == editorState.taskId);
            if (startIndex === -1) return;

            // Get current preset ID to check correct status
            const currentPid = appState.currentPreset ? appState.currentPreset.id : null;
            if (!currentPid) return;

            let newIndex = startIndex;
            let found = false;

            // Search loop
            while (true) {
                newIndex += direction;

                // Boundary checks
                if (newIndex < 0 || newIndex >= tasks.length) {
                    break; // Stop at edges
                }

                const task = tasks[newIndex];
                const result = task.results[currentPid];

                // Skip incomplete tasks (only allow 'completed' or 'edited')
                if (result && (result.status === 'completed' || result.status === 'edited')) {
                    found = true;
                    break;
                }
            }

            if (found && newIndex !== startIndex) {
                const newTask = tasks[newIndex];
                openAudioEditor(newTask.id);
            } else {
                showToast("æ²¡æœ‰æ›´å¤šå·²å®Œæˆçš„ä»»åŠ¡äº†", "info");
            }
        }

        function toggleEditorPlay() {
            if (editorState.wavesurfer) {
                if (editorState.isPlaying) {
                    // Pause both main and reference
                    editorState.wavesurfer.pause();
                    if (editorState.refWavesurfer) {
                        editorState.refWavesurfer.pause();
                    }
                } else {
                    // Resume AudioContext if suspended (browser autoplay policy)
                    if (editorState.audioContext && editorState.audioContext.state === 'suspended') {
                        editorState.audioContext.resume();
                    }
                    // Start playback
                    editorState.wavesurfer.play();
                }
            }
        }

        async function saveAudioEditor() {
            showToast("æ­£åœ¨æ¸²æŸ“éŸ³é¢‘...", "info");

            try {
                // 1. Decode Original
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const arrayBuffer = await editorState.originalBlob.arrayBuffer();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

                // 2. Setup Offline Context
                const rate = parseFloat(editorEls.sliderRate.value);
                const pitchCents = parseFloat(editorEls.sliderPitch.value);
                const effectiveRate = rate * Math.pow(2, pitchCents / 1200);

                // Adjust duration for speed
                const newDuration = audioBuffer.duration / effectiveRate;

                const offlineCtx = new OfflineAudioContext(
                    audioBuffer.numberOfChannels,
                    Math.ceil(newDuration * audioBuffer.sampleRate) + 50,
                    audioBuffer.sampleRate
                );

                // 3. Build Offline Graph
                const source = offlineCtx.createBufferSource();
                source.buffer = audioBuffer;

                // Params
                source.playbackRate.value = rate;
                source.detune.value = pitchCents;

                let lastNode = source;

                // Radio Effect
                if (editorEls.checkRadio.checked) {
                    const hp = offlineCtx.createBiquadFilter();
                    hp.type = 'highpass';
                    hp.frequency.value = 300;
                    lastNode.connect(hp);
                    lastNode = hp;

                    const lp = offlineCtx.createBiquadFilter();
                    lp.type = 'lowpass';
                    lp.frequency.value = 3500;
                    lastNode.connect(lp);
                    lastNode = lp;

                    const dist = offlineCtx.createWaveShaper();
                    dist.curve = makeDistortionCurve(50);
                    dist.oversample = '4x';
                    lastNode.connect(dist);
                    lastNode = dist;
                }

                // Volume
                const gain = offlineCtx.createGain();
                const volDb = parseFloat(editorEls.sliderVol.value);
                gain.gain.value = Math.pow(10, volDb / 20);

                lastNode.connect(gain);
                gain.connect(offlineCtx.destination);

                // 4. Render
                source.start();
                const renderedBuffer = await offlineCtx.startRendering();

                // 5. Encoded to WAV Blob
                const fmt = editorEls.exportFormat ? editorEls.exportFormat.value : '16';
                const options = fmt === '32f'
                    ? { bitDepth: 32, float: true }
                    : { bitDepth: 16, float: false };

                const wavBlob = bufferToWave(renderedBuffer, 0, renderedBuffer.length, options);

                // 6. Save back
                const task = appState.tasks.find(t => t.id == editorState.taskId);
                const currentPid = editorState.presetId;

                task.results[currentPid].blob = wavBlob;
                task.results[currentPid].status = 'edited';

                renderTable();

                // Custom Toast Message
                let msg = "éŸ³é¢‘å·²ä¿å­˜!";
                if (options.float) {
                    msg += " (32-bit Float)";
                } else if (editorState.originalBlob && editorState.originalBlob.type === 'audio/mpeg') {
                    msg += " (å·²è‡ªåŠ¨è½¬æ¢ä¸º WAV)";
                }
                showToast(msg, "success");

                // Visual Feedback: Change waveform color to Green (Edited)
                if (editorState.wavesurfer) {
                    editorState.wavesurfer.setOptions({
                        waveColor: '#4caf50', // Green
                        progressColor: '#81c784'
                    });
                }
                // Do NOT close editor
                // closeEditor();

            } catch (e) {
                console.error(e);
                showToast("æ¸²æŸ“å¤±è´¥: " + e.message, "error");
            }
        }

        // Utils
        function makeDistortionCurve(amount) {
            const k = typeof amount === 'number' ? amount : 50;
            const n_samples = 44100;
            const curve = new Float32Array(n_samples);
            const deg = Math.PI / 180;
            for (let i = 0; i < n_samples; ++i) {
                const x = i * 2 / n_samples - 1;
                curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
            }
            return curve;
        }

        function showConfirmModal(message) {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmModal');
                const msgEl = document.getElementById('confirmMessage');
                const btnOk = document.getElementById('btnConfirmOk');
                const btnCancel = document.getElementById('btnConfirmCancel');

                msgEl.textContent = message;
                modal.classList.remove('hidden');

                const cleanup = () => {
                    modal.classList.add('hidden');
                    btnOk.onclick = null;
                    btnCancel.onclick = null;
                };

                btnOk.onclick = () => {
                    cleanup();
                    resolve(true);
                };

                btnCancel.onclick = () => {
                    cleanup();
                    resolve(false);
                };
            });
        }

        function bufferToWave(abuffer, offset, len, options = { bitDepth: 16, float: false }) {
            const numOfChan = abuffer.numberOfChannels;
            // Bytes per sample: 16-bit = 2, 32-bit = 4
            const bytesPerSample = options.bitDepth === 32 ? 4 : 2;
            const formatTag = options.float ? 3 : 1; // 1 = PCM, 3 = IEEE Float

            const length = len * numOfChan * bytesPerSample + 44;
            const buffer = new ArrayBuffer(length);
            const view = new DataView(buffer);
            let channels = [], i, sample;
            let pos = 0;

            // Helpers
            function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
            function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }

            // RIFF chunk descriptor
            setUint32(0x46464952); // "RIFF"
            setUint32(length - 8); // file length - 8
            setUint32(0x45564157); // "WAVE"

            // fmt sub-chunk
            setUint32(0x20746d66); // "fmt "
            setUint32(16); // length = 16
            setUint16(formatTag);
            setUint16(numOfChan);
            setUint32(abuffer.sampleRate);
            setUint32(abuffer.sampleRate * numOfChan * bytesPerSample); // byte rate
            setUint16(numOfChan * bytesPerSample); // block-align
            setUint16(options.bitDepth); // bits per sample

            // data sub-chunk
            setUint32(0x61746164); // "data"
            setUint32(length - pos - 4);

            // write interleaved data
            for (i = 0; i < abuffer.numberOfChannels; i++)
                channels.push(abuffer.getChannelData(i));

            while (pos < length) {
                for (i = 0; i < numOfChan; i++) {
                    const s = channels[i][offset]; // Raw float sample (-1.0 to 1.0)

                    if (options.float) {
                        // 32-bit Float
                        view.setFloat32(pos, s, true);
                        pos += 4;
                    } else {
                        // 16-bit PCM (Clamped)
                        sample = Math.max(-1, Math.min(1, s));
                        sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;
                        view.setInt16(pos, sample, true);
                        pos += 2;
                    }
                }
                offset++;
            }

            return new Blob([buffer], { type: "audio/wav" });
        }

    </script>

</html>